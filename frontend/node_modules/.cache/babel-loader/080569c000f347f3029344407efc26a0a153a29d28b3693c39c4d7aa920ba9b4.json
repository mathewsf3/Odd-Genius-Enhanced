{"ast":null,"code":"import axios from 'axios';\nimport { API_KEY } from '../config/api-config';\n\n// Base URL for AllSportsAPI\nconst API_BASE_URL = 'https://apiv2.allsportsapi.com/football/';\n\n// Helper function to determine confidence level\nconst determineConfidence = probability => {\n  if (probability >= 0.7 || probability <= 0.3) return 'High';\n  if (probability >= 0.6 || probability <= 0.4) return 'Medium';\n  return 'Low';\n};\n\n// Helper function to determine recommendation\nconst determineRecommendation = overProbability => {\n  if (overProbability > 0.55) return 'OVER';\n  if (overProbability < 0.45) return 'UNDER';\n  return 'PUSH';\n};\n\n// Helper function to calculate value indicator\nconst calculateValueIndicator = (probability, odds) => {\n  const impliedProbability = 1 / odds;\n  const edge = probability - impliedProbability;\n  if (edge > 0.05) return 'Value';\n  if (edge > -0.05) return 'Fair';\n  return 'Poor';\n};\n\n// Helper function to calculate hit rates from match data\nconst calculateHitRates = (matches, line, statKey) => {\n  if (!matches || matches.length === 0) {\n    return {\n      over: 0,\n      under: 0,\n      push: 0,\n      total: 0\n    };\n  }\n  let over = 0;\n  let under = 0;\n  let push = 0;\n  matches.forEach(match => {\n    const value = match[statKey] || 0;\n    if (value > line) over++;else if (value < line) under++;else push++;\n  });\n  return {\n    over,\n    under,\n    push,\n    total: matches.length,\n    overRate: over / matches.length,\n    underRate: under / matches.length,\n    pushRate: push / matches.length\n  };\n};\n\n// Main service class\nclass OverUnderMarketService {\n  // Fetch team fixtures\n  async fetchTeamFixtures(teamId, limit = 20) {\n    try {\n      const response = await axios.get(`${API_BASE_URL}`, {\n        params: {\n          met: 'Fixtures',\n          teamId,\n          APIkey: API_KEY\n        }\n      });\n      if (response.data && response.data.success === 1 && response.data.result) {\n        return response.data.result.slice(0, limit);\n      }\n      return [];\n    } catch (error) {\n      console.error('Error fetching team fixtures:', error);\n      throw error;\n    }\n  }\n\n  // Fetch head-to-head matches\n  async fetchH2HMatches(team1Id, team2Id, limit = 10) {\n    try {\n      const response = await axios.get(`${API_BASE_URL}`, {\n        params: {\n          met: 'H2H',\n          firstTeamId: team1Id,\n          secondTeamId: team2Id,\n          APIkey: API_KEY\n        }\n      });\n      if (response.data && response.data.success === 1 && response.data.result) {\n        return response.data.result.slice(0, limit);\n      }\n      return [];\n    } catch (error) {\n      console.error('Error fetching H2H matches:', error);\n      throw error;\n    }\n  }\n\n  // Fetch league statistics\n  async fetchLeagueStats(leagueId) {\n    try {\n      const response = await axios.get(`${API_BASE_URL}`, {\n        params: {\n          met: 'Standings',\n          leagueId,\n          APIkey: API_KEY\n        }\n      });\n      if (response.data && response.data.success === 1) {\n        return response.data.result;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching league stats:', error);\n      throw error;\n    }\n  }\n\n  // Fetch referee statistics\n  async fetchRefereeStats(leagueId, refereeName) {\n    try {\n      // First get fixtures from the league\n      const response = await axios.get(`${API_BASE_URL}`, {\n        params: {\n          met: 'Fixtures',\n          leagueId,\n          APIkey: API_KEY,\n          from: '2023-01-01',\n          to: '2025-12-31'\n        }\n      });\n      if (response.data && response.data.success === 1 && response.data.result) {\n        // Filter fixtures by referee\n        const refereeMatches = response.data.result.filter(match => match.event_referee && match.event_referee.includes(refereeName));\n        return refereeMatches;\n      }\n      return [];\n    } catch (error) {\n      console.error('Error fetching referee stats:', error);\n      throw error;\n    }\n  }\n\n  // Process team data for a specific market\n  async processTeamMarketData(team, fixtures, statKey, line) {\n    // Split fixtures into home and away\n    const homeFixtures = fixtures.filter(f => f.event_home_team === team.name || f.match_hometeam_name === team.name);\n    const awayFixtures = fixtures.filter(f => f.event_away_team === team.name || f.match_awayteam_name === team.name);\n\n    // Calculate averages\n    const getAverage = (matches, key) => {\n      if (!matches || matches.length === 0) return 0;\n      const sum = matches.reduce((acc, match) => acc + (match[key] || 0), 0);\n      return sum / matches.length;\n    };\n    const overallAvg = getAverage(fixtures, statKey);\n    const homeAvg = getAverage(homeFixtures, statKey);\n    const awayAvg = getAverage(awayFixtures, statKey);\n\n    // Calculate hit rates\n    const last5 = fixtures.slice(0, 5);\n    const last10 = fixtures.slice(0, 10);\n    const season = fixtures;\n\n    // Create trend data (last 10 matches)\n    const trend = last10.map(match => match[statKey] || 0);\n\n    // Create distribution data\n    const distribution = {};\n    fixtures.forEach(match => {\n      const value = match[statKey] || 0;\n      distribution[value] = (distribution[value] || 0) + 1;\n    });\n\n    // Convert counts to percentages\n    Object.keys(distribution).forEach(key => {\n      distribution[key] = distribution[key] / fixtures.length * 100;\n    });\n    return {\n      team,\n      overall: {\n        average: overallAvg,\n        hitRates: {\n          last5: calculateHitRates(last5, line, statKey),\n          last10: calculateHitRates(last10, line, statKey),\n          season: calculateHitRates(season, line, statKey)\n        }\n      },\n      home: {\n        average: homeAvg,\n        hitRates: {\n          last5: calculateHitRates(homeFixtures.slice(0, 5), line, statKey),\n          last10: calculateHitRates(homeFixtures.slice(0, 10), line, statKey),\n          season: calculateHitRates(homeFixtures, line, statKey)\n        }\n      },\n      away: {\n        average: awayAvg,\n        hitRates: {\n          last5: calculateHitRates(awayFixtures.slice(0, 5), line, statKey),\n          last10: calculateHitRates(awayFixtures.slice(0, 10), line, statKey),\n          season: calculateHitRates(awayFixtures, line, statKey)\n        }\n      },\n      trend,\n      distribution\n    };\n  }\n\n  // Main method to fetch all over/under market data\n  async fetchOverUnderMarketData(match, timePeriod = 'last10') {\n    try {\n      console.log('[OverUnderMarketService] Processing match data:', match);\n\n      // Use the match data passed from the component\n      const homeTeam = match.homeTeam;\n      const awayTeam = match.awayTeam;\n      const league = match.league;\n      console.log('[OverUnderMarketService] Fetching real API data for:', homeTeam.name, 'vs', awayTeam.name, 'with time period:', timePeriod);\n\n      // Determine the number of matches to fetch based on time period\n      const matchLimit = this.getMatchLimitForTimePeriod(timePeriod);\n      console.log('[OverUnderMarketService] Using match limit:', matchLimit, 'for time period:', timePeriod);\n\n      // Fetch real team fixtures data\n      let homeTeamFixtures = [];\n      let awayTeamFixtures = [];\n      let h2hMatches = [];\n      let leagueStats = null;\n      try {\n        // Fetch home team fixtures\n        console.log('[OverUnderMarketService] Fetching home team fixtures for:', homeTeam.name);\n        homeTeamFixtures = await this.fetchTeamFixtures(homeTeam.id, matchLimit);\n        console.log('[OverUnderMarketService] Home team fixtures:', homeTeamFixtures.length, 'matches');\n\n        // Fetch away team fixtures\n        console.log('[OverUnderMarketService] Fetching away team fixtures for:', awayTeam.name);\n        awayTeamFixtures = await this.fetchTeamFixtures(awayTeam.id, matchLimit);\n        console.log('[OverUnderMarketService] Away team fixtures:', awayTeamFixtures.length, 'matches');\n\n        // Fetch head-to-head matches (always use a reasonable limit for H2H)\n        console.log('[OverUnderMarketService] Fetching H2H matches');\n        h2hMatches = await this.fetchH2HMatches(homeTeam.id, awayTeam.id, Math.min(10, matchLimit));\n        console.log('[OverUnderMarketService] H2H matches:', h2hMatches.length, 'matches');\n\n        // Fetch league stats\n        console.log('[OverUnderMarketService] Fetching league stats for:', league.name);\n        leagueStats = await this.fetchLeagueStats(league.id);\n        console.log('[OverUnderMarketService] League stats:', leagueStats ? 'available' : 'not available');\n      } catch (apiError) {\n        console.warn('[OverUnderMarketService] API fetch error:', apiError);\n        // Continue with available data\n      }\n\n      // Process the real data to calculate market probabilities\n      console.log('[OverUnderMarketService] Processing goal markets with', homeTeamFixtures.length, 'home fixtures,', awayTeamFixtures.length, 'away fixtures,', h2hMatches.length, 'H2H matches');\n      const goalMarkets = this.processGoalMarkets(homeTeamFixtures, awayTeamFixtures, h2hMatches);\n      console.log('[OverUnderMarketService] Generated', goalMarkets.length, 'goal markets');\n      const cardMarkets = this.processCardMarkets(homeTeamFixtures, awayTeamFixtures, h2hMatches);\n      console.log('[OverUnderMarketService] Generated', cardMarkets.length, 'card markets');\n      const cornerMarkets = this.processCornerMarkets(homeTeamFixtures, awayTeamFixtures, h2hMatches);\n      console.log('[OverUnderMarketService] Generated', cornerMarkets.length, 'corner markets');\n      const teamSpecificMarkets = this.processTeamSpecificMarkets(homeTeamFixtures, awayTeamFixtures);\n      console.log('[OverUnderMarketService] Generated team-specific markets');\n\n      // Determine data quality based on available data\n      const dataQuality = this.assessDataQuality(homeTeamFixtures, awayTeamFixtures, h2hMatches);\n      console.log('[OverUnderMarketService] Processed real market data successfully');\n      return {\n        match: {\n          id: match.id,\n          homeTeam,\n          awayTeam,\n          league,\n          date: match.date || new Date().toISOString().split('T')[0],\n          time: match.time || '15:00'\n        },\n        goalMarkets,\n        cardMarkets,\n        cornerMarkets,\n        teamSpecificMarkets,\n        dataQuality,\n        lastUpdated: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Error fetching over/under market data:', error);\n      throw error;\n    }\n  }\n\n  // Process goal markets from real fixture data\n  processGoalMarkets(homeFixtures, awayFixtures, h2hMatches) {\n    const goalLines = [0.5, 1.5, 2.5, 3.5, 4.5];\n    const goalMarkets = [];\n    goalLines.forEach(line => {\n      // Calculate home team goal statistics\n      const homeGoalStats = this.calculateGoalStats(homeFixtures, line);\n      const awayGoalStats = this.calculateGoalStats(awayFixtures, line);\n      const h2hGoalStats = this.calculateGoalStats(h2hMatches, line);\n\n      // Calculate combined probability\n      const combinedAverage = (homeGoalStats.average + awayGoalStats.average) / 2;\n      const overProbability = combinedAverage > line ? 0.6 + Math.min(0.3, (combinedAverage - line) * 0.1) : 0.4 - Math.min(0.3, (line - combinedAverage) * 0.1);\n      const goalMarket = {\n        line,\n        probability: {\n          over: Math.max(0.1, Math.min(0.9, overProbability)),\n          under: Math.max(0.1, Math.min(0.9, 1 - overProbability)),\n          push: 0,\n          confidence: determineConfidence(overProbability),\n          recommendation: determineRecommendation(overProbability),\n          sampleSize: Math.min(homeFixtures.length, awayFixtures.length)\n        },\n        homeTeam: {},\n        // Simplified for now\n        awayTeam: {},\n        // Simplified for now\n        league: {\n          average: 2.7,\n          // Default Serie A average\n          hitRate: {\n            over: 0.55,\n            under: 0.45\n          }\n        },\n        h2h: {\n          average: h2hGoalStats.average,\n          hitRate: {\n            over: h2hGoalStats.overRate,\n            under: h2hGoalStats.underRate,\n            push: h2hGoalStats.pushRate,\n            total: h2hMatches.length\n          }\n        }\n      };\n      goalMarkets.push(goalMarket);\n    });\n    return goalMarkets;\n  }\n\n  // Process card markets from real fixture data\n  processCardMarkets(homeFixtures, awayFixtures, h2hMatches) {\n    const cardLines = [2.5, 3.5, 4.5, 5.5];\n    const cardMarkets = [];\n    cardLines.forEach(line => {\n      // Calculate card statistics\n      const homeCardStats = this.calculateCardStats(homeFixtures, line);\n      const awayCardStats = this.calculateCardStats(awayFixtures, line);\n      const h2hCardStats = this.calculateCardStats(h2hMatches, line);\n\n      // Calculate combined probability\n      const combinedAverage = (homeCardStats.average + awayCardStats.average) / 2;\n      const overProbability = combinedAverage > line ? 0.55 + Math.min(0.3, (combinedAverage - line) * 0.08) : 0.45 - Math.min(0.3, (line - combinedAverage) * 0.08);\n      const cardMarket = {\n        line,\n        probability: {\n          over: Math.max(0.1, Math.min(0.9, overProbability)),\n          under: Math.max(0.1, Math.min(0.9, 1 - overProbability)),\n          push: 0,\n          confidence: determineConfidence(overProbability),\n          recommendation: determineRecommendation(overProbability),\n          sampleSize: Math.min(homeFixtures.length, awayFixtures.length)\n        },\n        homeTeam: {},\n        // Simplified for now\n        awayTeam: {},\n        // Simplified for now\n        referee: {\n          name: 'Serie A Referee',\n          average: 4.2,\n          hitRate: {\n            over: 0.52,\n            under: 0.48\n          }\n        },\n        league: {\n          average: 3.8,\n          // Default Serie A average\n          hitRate: {\n            over: 0.48,\n            under: 0.52\n          }\n        },\n        h2h: {\n          average: h2hCardStats.average,\n          hitRate: {\n            over: h2hCardStats.overRate,\n            under: h2hCardStats.underRate,\n            push: h2hCardStats.pushRate,\n            total: h2hMatches.length\n          }\n        }\n      };\n      cardMarkets.push(cardMarket);\n    });\n    return cardMarkets;\n  }\n\n  // Process corner markets from real fixture data\n  processCornerMarkets(homeFixtures, awayFixtures, h2hMatches) {\n    const cornerLines = [7.5, 8.5, 9.5, 10.5, 11.5];\n    const cornerMarkets = [];\n    cornerLines.forEach(line => {\n      // Calculate corner statistics\n      const homeCornerStats = this.calculateCornerStats(homeFixtures, line);\n      const awayCornerStats = this.calculateCornerStats(awayFixtures, line);\n      const h2hCornerStats = this.calculateCornerStats(h2hMatches, line);\n\n      // Calculate combined probability\n      const combinedAverage = (homeCornerStats.average + awayCornerStats.average) / 2;\n      const overProbability = combinedAverage > line ? 0.5 + Math.min(0.3, (combinedAverage - line) * 0.05) : 0.5 - Math.min(0.3, (line - combinedAverage) * 0.05);\n      const cornerMarket = {\n        line,\n        probability: {\n          over: Math.max(0.1, Math.min(0.9, overProbability)),\n          under: Math.max(0.1, Math.min(0.9, 1 - overProbability)),\n          push: 0,\n          confidence: determineConfidence(overProbability),\n          recommendation: determineRecommendation(overProbability),\n          sampleSize: Math.min(homeFixtures.length, awayFixtures.length)\n        },\n        homeTeam: {},\n        // Simplified for now\n        awayTeam: {},\n        // Simplified for now\n        league: {\n          average: 10.2,\n          // Default Serie A average\n          hitRate: {\n            over: 0.48,\n            under: 0.52\n          }\n        },\n        h2h: {\n          average: h2hCornerStats.average,\n          hitRate: {\n            over: h2hCornerStats.overRate,\n            under: h2hCornerStats.underRate,\n            push: h2hCornerStats.pushRate,\n            total: h2hMatches.length\n          }\n        },\n        halfDistribution: {\n          firstHalf: 45,\n          secondHalf: 55\n        }\n      };\n      cornerMarkets.push(cornerMarket);\n    });\n    return cornerMarkets;\n  }\n\n  // Process team-specific markets\n  processTeamSpecificMarkets(homeFixtures, awayFixtures) {\n    // Calculate team-specific goal probabilities\n    const homeGoalStats = this.calculateGoalStats(homeFixtures, 1.5);\n    const awayGoalStats = this.calculateGoalStats(awayFixtures, 1.5);\n    const homeCardStats = this.calculateCardStats(homeFixtures, 1.5);\n    const awayCardStats = this.calculateCardStats(awayFixtures, 1.5);\n    const homeCornerStats = this.calculateCornerStats(homeFixtures, 4.5);\n    const awayCornerStats = this.calculateCornerStats(awayFixtures, 4.5);\n    return {\n      goals: {\n        home: {\n          line: 1.5,\n          probability: {\n            over: Math.max(0.1, Math.min(0.9, homeGoalStats.overRate)),\n            under: Math.max(0.1, Math.min(0.9, homeGoalStats.underRate)),\n            push: 0,\n            confidence: determineConfidence(homeGoalStats.overRate),\n            recommendation: determineRecommendation(homeGoalStats.overRate),\n            sampleSize: homeFixtures.length\n          },\n          teamData: {}\n        },\n        away: {\n          line: 1.5,\n          probability: {\n            over: Math.max(0.1, Math.min(0.9, awayGoalStats.overRate)),\n            under: Math.max(0.1, Math.min(0.9, awayGoalStats.underRate)),\n            push: 0,\n            confidence: determineConfidence(awayGoalStats.overRate),\n            recommendation: determineRecommendation(awayGoalStats.overRate),\n            sampleSize: awayFixtures.length\n          },\n          teamData: {}\n        }\n      },\n      cards: {\n        home: {\n          line: 1.5,\n          probability: {\n            over: Math.max(0.1, Math.min(0.9, homeCardStats.overRate)),\n            under: Math.max(0.1, Math.min(0.9, homeCardStats.underRate)),\n            push: 0,\n            confidence: determineConfidence(homeCardStats.overRate),\n            recommendation: determineRecommendation(homeCardStats.overRate),\n            sampleSize: homeFixtures.length\n          },\n          teamData: {}\n        },\n        away: {\n          line: 1.5,\n          probability: {\n            over: Math.max(0.1, Math.min(0.9, awayCardStats.overRate)),\n            under: Math.max(0.1, Math.min(0.9, awayCardStats.underRate)),\n            push: 0,\n            confidence: determineConfidence(awayCardStats.overRate),\n            recommendation: determineRecommendation(awayCardStats.overRate),\n            sampleSize: awayFixtures.length\n          },\n          teamData: {}\n        }\n      },\n      corners: {\n        home: {\n          line: 4.5,\n          probability: {\n            over: Math.max(0.1, Math.min(0.9, homeCornerStats.overRate)),\n            under: Math.max(0.1, Math.min(0.9, homeCornerStats.underRate)),\n            push: 0,\n            confidence: determineConfidence(homeCornerStats.overRate),\n            recommendation: determineRecommendation(homeCornerStats.overRate),\n            sampleSize: homeFixtures.length\n          },\n          teamData: {}\n        },\n        away: {\n          line: 4.5,\n          probability: {\n            over: Math.max(0.1, Math.min(0.9, awayCornerStats.overRate)),\n            under: Math.max(0.1, Math.min(0.9, awayCornerStats.underRate)),\n            push: 0,\n            confidence: determineConfidence(awayCornerStats.overRate),\n            recommendation: determineRecommendation(awayCornerStats.overRate),\n            sampleSize: awayFixtures.length\n          },\n          teamData: {}\n        }\n      }\n    };\n  }\n\n  // Calculate goal statistics from fixtures\n  calculateGoalStats(fixtures, line) {\n    if (!fixtures || fixtures.length === 0) {\n      return {\n        average: 0,\n        overRate: 0.5,\n        underRate: 0.5,\n        pushRate: 0\n      };\n    }\n    let totalGoals = 0;\n    let overCount = 0;\n    let underCount = 0;\n    let pushCount = 0;\n    fixtures.forEach(fixture => {\n      const goals = this.extractGoalsFromFixture(fixture);\n      totalGoals += goals;\n      if (goals > line) overCount++;else if (goals < line) underCount++;else pushCount++;\n    });\n    return {\n      average: totalGoals / fixtures.length,\n      overRate: overCount / fixtures.length,\n      underRate: underCount / fixtures.length,\n      pushRate: pushCount / fixtures.length\n    };\n  }\n\n  // Calculate card statistics from fixtures\n  calculateCardStats(fixtures, line) {\n    if (!fixtures || fixtures.length === 0) {\n      return {\n        average: 0,\n        overRate: 0.5,\n        underRate: 0.5,\n        pushRate: 0\n      };\n    }\n    let totalCards = 0;\n    let overCount = 0;\n    let underCount = 0;\n    let pushCount = 0;\n    fixtures.forEach(fixture => {\n      const cards = this.extractCardsFromFixture(fixture);\n      totalCards += cards;\n      if (cards > line) overCount++;else if (cards < line) underCount++;else pushCount++;\n    });\n    return {\n      average: totalCards / fixtures.length,\n      overRate: overCount / fixtures.length,\n      underRate: underCount / fixtures.length,\n      pushRate: pushCount / fixtures.length\n    };\n  }\n\n  // Calculate corner statistics from fixtures\n  calculateCornerStats(fixtures, line) {\n    if (!fixtures || fixtures.length === 0) {\n      return {\n        average: 0,\n        overRate: 0.5,\n        underRate: 0.5,\n        pushRate: 0\n      };\n    }\n    let totalCorners = 0;\n    let overCount = 0;\n    let underCount = 0;\n    let pushCount = 0;\n    fixtures.forEach(fixture => {\n      const corners = this.extractCornersFromFixture(fixture);\n      totalCorners += corners;\n      if (corners > line) overCount++;else if (corners < line) underCount++;else pushCount++;\n    });\n    return {\n      average: totalCorners / fixtures.length,\n      overRate: overCount / fixtures.length,\n      underRate: underCount / fixtures.length,\n      pushRate: pushCount / fixtures.length\n    };\n  }\n\n  // Extract goals from fixture data\n  extractGoalsFromFixture(fixture) {\n    // Try different possible field names for goals\n    const homeGoals = fixture.event_home_final_result || fixture.match_hometeam_score || fixture.home_score || 0;\n    const awayGoals = fixture.event_away_final_result || fixture.match_awayteam_score || fixture.away_score || 0;\n    return parseInt(homeGoals) + parseInt(awayGoals) || 0;\n  }\n\n  // Extract cards from fixture data\n  extractCardsFromFixture(fixture) {\n    // Try different possible field names for cards\n    const homeYellow = fixture.event_home_yellow_cards || fixture.home_yellow_cards || 0;\n    const awayYellow = fixture.event_away_yellow_cards || fixture.away_yellow_cards || 0;\n    const homeRed = fixture.event_home_red_cards || fixture.home_red_cards || 0;\n    const awayRed = fixture.event_away_red_cards || fixture.away_red_cards || 0;\n\n    // Red cards count as 2 for betting purposes\n    return parseInt(homeYellow) + parseInt(awayYellow) + parseInt(homeRed) * 2 + parseInt(awayRed) * 2 || 0;\n  }\n\n  // Extract corners from fixture data\n  extractCornersFromFixture(fixture) {\n    // Try different possible field names for corners\n    const homeCorners = fixture.event_home_corners || fixture.home_corners || 0;\n    const awayCorners = fixture.event_away_corners || fixture.away_corners || 0;\n    return parseInt(homeCorners) + parseInt(awayCorners) || 0;\n  }\n\n  // Get match limit based on time period\n  getMatchLimitForTimePeriod(timePeriod) {\n    switch (timePeriod) {\n      case 'last5':\n        return 5;\n      case 'last10':\n        return 10;\n      case 'season':\n        return 38;\n      // Full season for most leagues\n      default:\n        return 10;\n    }\n  }\n\n  // Assess data quality based on available data\n  assessDataQuality(homeFixtures, awayFixtures, h2hMatches) {\n    const homeDataQuality = homeFixtures.length >= 10 ? 'High' : homeFixtures.length >= 5 ? 'Medium' : 'Low';\n    const awayDataQuality = awayFixtures.length >= 10 ? 'High' : awayFixtures.length >= 5 ? 'Medium' : 'Low';\n    const h2hDataQuality = h2hMatches.length >= 5 ? 'High' : h2hMatches.length >= 3 ? 'Medium' : 'Low';\n\n    // Overall quality is the lowest of the three\n    const qualities = [homeDataQuality, awayDataQuality, h2hDataQuality];\n    const overallQuality = qualities.includes('Low') ? 'Low' : qualities.includes('Medium') ? 'Medium' : 'High';\n    return {\n      overall: overallQuality,\n      goals: homeDataQuality,\n      cards: awayDataQuality,\n      corners: h2hDataQuality\n    };\n  }\n}\nexport default new OverUnderMarketService();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}