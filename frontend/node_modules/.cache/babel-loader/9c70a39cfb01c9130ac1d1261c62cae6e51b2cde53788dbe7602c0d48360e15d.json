{"ast":null,"code":"import axios from 'axios';\nimport soccerApiService from '../api/soccerApiService';\nclass ChatService {\n  constructor() {\n    this.apiKey = void 0;\n    this.baseUrl = void 0;\n    this.apiKey = process.env.REACT_APP_OPENAI_API_KEY || '';\n    this.baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\n  }\n  isValidSoccerQuery(message) {\n    const messageLower = message.toLowerCase();\n    const commonTeams = ['spain', 'france', 'england', 'germany', 'brazil', 'argentina', 'portugal', 'italy', 'netherlands', 'belgium', 'croatia', 'uruguay', 'manchester united', 'manchester city', 'liverpool', 'chelsea', 'arsenal', 'tottenham', 'barcelona', 'real madrid', 'atletico madrid', 'bayern munich', 'borussia dortmund', 'psg', 'juventus', 'ac milan', 'inter milan', 'napoli', 'ajax', 'benfica', 'porto'];\n\n    // Return true if message contains any common team name\n    if (commonTeams.some(team => messageLower.includes(team.toLowerCase()))) {\n      return true;\n    }\n\n    // Return true for any soccer-related query\n    const soccerKeywords = ['soccer', 'football', 'match', 'team', 'league', 'goal', 'score', 'bet', 'odds', 'statistics', 'analysis', 'prediction', 'premier league', 'champions league', 'la liga', 'serie a', 'bundesliga', 'ligue 1', 'mls', 'world cup', 'euro', 'player', 'coach', 'transfer', 'formation', 'tactics', 'expected goals', 'xg', 'xa', 'possession', 'shots', 'corners', 'cards', 'fouls', 'offside', 'penalty', 'free kick', 'striker', 'midfielder', 'defender', 'goalkeeper'];\n    return soccerKeywords.some(keyword => messageLower.includes(keyword));\n  }\n  async getRecentMatchData() {\n    try {\n      // Get live and upcoming matches\n      const [liveMatches, upcomingMatches] = await Promise.all([soccerApiService.getLiveMatches().catch(() => ({\n        result: []\n      })), soccerApiService.getUpcomingMatches().catch(() => ({\n        result: []\n      }))]);\n      const liveData = (liveMatches === null || liveMatches === void 0 ? void 0 : liveMatches.result) || liveMatches || [];\n      const upcomingData = (upcomingMatches === null || upcomingMatches === void 0 ? void 0 : upcomingMatches.result) || upcomingMatches || [];\n\n      // Get next 7 days of matches\n      const now = new Date();\n      const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);\n      const recentMatches = Array.isArray(upcomingData) ? upcomingData.filter(match => {\n        const matchDate = new Date(`${match.date} ${match.time}`);\n        return matchDate >= now && matchDate <= nextWeek;\n      }).slice(0, 20) : [];\n      return {\n        liveMatches: Array.isArray(liveData) ? liveData.slice(0, 10) : [],\n        upcomingMatches: recentMatches,\n        totalLive: Array.isArray(liveData) ? liveData.length : 0,\n        totalUpcoming: recentMatches.length,\n        rawLiveData: liveData,\n        rawUpcomingData: upcomingData\n      };\n    } catch (error) {\n      console.error('Error fetching match data:', error);\n      return {\n        liveMatches: [],\n        upcomingMatches: [],\n        totalLive: 0,\n        totalUpcoming: 0,\n        rawLiveData: [],\n        rawUpcomingData: []\n      };\n    }\n  }\n  async getLeagueData() {\n    try {\n      // Get popular leagues data if available\n      const leagues = ['Premier League', 'Champions League', 'La Liga', 'Serie A', 'Bundesliga', 'Ligue 1'];\n      return {\n        availableLeagues: leagues,\n        note: \"I can provide analysis for major European leagues and competitions\"\n      };\n    } catch (error) {\n      console.error('Error fetching league data:', error);\n      return {\n        availableLeagues: [],\n        note: \"League data temporarily unavailable\"\n      };\n    }\n  }\n  createSystemPrompt(matchData, leagueData) {\n    const liveMatchesInfo = matchData.liveMatches.map(match => {\n      var _match$homeTeam, _match$awayTeam, _match$score, _match$score2, _match$league;\n      return `${(_match$homeTeam = match.homeTeam) === null || _match$homeTeam === void 0 ? void 0 : _match$homeTeam.name} vs ${(_match$awayTeam = match.awayTeam) === null || _match$awayTeam === void 0 ? void 0 : _match$awayTeam.name} (${(_match$score = match.score) === null || _match$score === void 0 ? void 0 : _match$score.home}-${(_match$score2 = match.score) === null || _match$score2 === void 0 ? void 0 : _match$score2.away}, ${match.elapsed}', League: ${(_match$league = match.league) === null || _match$league === void 0 ? void 0 : _match$league.name})`;\n    }).slice(0, 5).join(', ');\n    const upcomingMatchesInfo = matchData.upcomingMatches.map(match => {\n      var _match$homeTeam2, _match$awayTeam2, _match$league2, _match$odds, _match$odds2, _match$odds3;\n      return `${(_match$homeTeam2 = match.homeTeam) === null || _match$homeTeam2 === void 0 ? void 0 : _match$homeTeam2.name} vs ${(_match$awayTeam2 = match.awayTeam) === null || _match$awayTeam2 === void 0 ? void 0 : _match$awayTeam2.name} (${match.date} ${match.time}, League: ${(_match$league2 = match.league) === null || _match$league2 === void 0 ? void 0 : _match$league2.name}, Odds: ${(_match$odds = match.odds) === null || _match$odds === void 0 ? void 0 : _match$odds.home}/${(_match$odds2 = match.odds) === null || _match$odds2 === void 0 ? void 0 : _match$odds2.draw}/${(_match$odds3 = match.odds) === null || _match$odds3 === void 0 ? void 0 : _match$odds3.away})`;\n    }).slice(0, 5).join(', ');\n    return `You are Odd Genius AI, a specialized soccer analytics assistant with access to REAL-TIME data. You help users with:\n\n**CURRENT LIVE MATCHES** (${matchData.totalLive} ongoing):\n${liveMatchesInfo || 'No live matches currently'}\n\n**UPCOMING MATCHES** (Next 7 days - ${matchData.totalUpcoming} matches):\n${upcomingMatchesInfo || 'No upcoming matches in the next 7 days'}\n\n**Your Capabilities:**\n1. **Real-Time Analysis**: Provide insights on the actual live and upcoming matches shown above\n2. **Betting Insights**: Use the real odds data (home/draw/away) for value betting recommendations\n3. **League Analysis**: Analyze patterns from the leagues currently active\n4. **Match Predictions**: Base predictions on the actual upcoming fixtures\n5. **Statistical Analysis**: Reference real team performance from current data\n\n**IMPORTANT GUIDELINES:**\n- ALWAYS use the real match data provided above when answering questions\n- When asked about \"today's matches\" or \"live matches\", reference the actual live matches listed\n- When asked about upcoming matches, use the actual upcoming fixtures provided\n- Provide specific team names, leagues, odds, and match times from the real data\n- If asked about matches not in the current data, explain that you can only analyze currently available matches\n- For betting advice, reference the actual odds shown in the data\n- NEVER make up match data - only use what's provided above\n\n**Data Context:**\n- Live matches include real scores, elapsed time, and venues\n- Upcoming matches include actual odds for home/draw/away outcomes\n- All data is current and updated in real-time\n\nRespond with specific, actionable insights based on the real match data provided.`;\n  }\n  async sendMessage(message) {\n    try {\n      var _response$data, _response$data$choice, _response$data$choice2, _response$data$choice3;\n      // Validate if the query is soccer-related\n      if (!this.isValidSoccerQuery(message)) {\n        return \"I'm your soccer analytics assistant! I can only help with soccer-related questions like match predictions, team analysis, betting insights, league statistics, and player performance. What would you like to know about soccer?\";\n      }\n\n      // Get recent soccer data first for dynamic analysis\n      const [matchData, leagueData] = await Promise.all([this.getRecentMatchData(), this.getLeagueData()]);\n\n      // ENHANCED: Check for specific match queries with dynamic search\n      const messageLower = message.toLowerCase();\n\n      // Extract potential team names from the message\n      const teamNamePatterns = [\n      // VS style patterns\n      /(\\w+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+)/gi, /(\\w+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+[\\s\\w]+)/gi, /(\\w+[\\s\\w]+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+)/gi, /(\\w+[\\s\\w]+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+[\\s\\w]+)/gi,\n      // Match/game/analysis style patterns\n      /(\\w+)\\s+(\\w+)(?:\\s+match|\\s+game|\\s+analysis)/gi, /(\\w+[\\s\\w]+)\\s+(\\w+)(?:\\s+match|\\s+game|\\s+analysis)/gi, /(\\w+)\\s+(\\w+[\\s\\w]+)(?:\\s+match|\\s+game|\\s+analysis)/gi, /(\\w+[\\s\\w]+)\\s+(\\w+[\\s\\w]+)(?:\\s+match|\\s+game|\\s+analysis)/gi,\n      // Between patterns\n      /(?:match|game)\\s+(?:between\\s+)?(\\w+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+)/gi, /(?:match|game)\\s+(?:between\\s+)?(\\w+[\\s\\w]+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+)/gi, /(?:match|game)\\s+(?:between\\s+)?(\\w+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+[\\s\\w]+)/gi, /(?:match|game)\\s+(?:between\\s+)?(\\w+[\\s\\w]+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+[\\s\\w]+)/gi];\n      let searchTerms = [];\n\n      // Try to extract team names using the patterns\n      for (const pattern of teamNamePatterns) {\n        const matches = [...message.matchAll(pattern)];\n        if (matches.length > 0) {\n          // Clean up the extracted team names\n          const team1 = matches[0][1].trim();\n          const team2 = matches[0][2].trim();\n\n          // Validate that the extracted teams are not common words or too short\n          if (this.isValidTeamName(team1) && this.isValidTeamName(team2)) {\n            searchTerms = [team1, team2];\n            break;\n          }\n        }\n      }\n\n      // Also check for common team names mentioned in the message\n      if (searchTerms.length < 2) {\n        const commonTeams = ['spain', 'france', 'england', 'germany', 'brazil', 'argentina', 'portugal', 'italy', 'netherlands', 'belgium', 'croatia', 'uruguay', 'manchester united', 'manchester city', 'liverpool', 'chelsea', 'arsenal', 'tottenham', 'barcelona', 'real madrid', 'atletico madrid', 'bayern munich', 'borussia dortmund', 'psg', 'juventus', 'ac milan', 'inter milan', 'napoli', 'ajax', 'benfica', 'porto'];\n        const foundTeams = commonTeams.filter(team => messageLower.includes(team.toLowerCase()));\n        if (foundTeams.length >= 2) {\n          searchTerms = foundTeams.slice(0, 2);\n        } else if (foundTeams.length === 1 && searchTerms.length === 1 && searchTerms[0] !== foundTeams[0]) {\n          searchTerms.push(foundTeams[0]);\n        } else if (foundTeams.length === 1 && searchTerms.length === 0) {\n          searchTerms = [foundTeams[0]];\n        }\n      }\n\n      // If we found potential team names, try dynamic match search\n      if (searchTerms.length > 0) {\n        console.log('Searching for match with teams:', searchTerms);\n        const foundMatch = await this.findMatchDynamically(searchTerms);\n        if (foundMatch) {\n          // Get detailed analysis for this specific match\n          const detailedData = foundMatch.id ? await this.getDetailedMatchAnalysis(foundMatch.id) : null;\n          return this.formatComprehensiveMatchAnalysis(foundMatch, detailedData);\n        } else {\n          // No exact match found, but provide helpful alternative\n          return `🔍 I couldn't find a specific match with ${searchTerms.join(' and ')} in the current fixtures.\\n\\n📅 **Available Matches:**\\n${this.formatUpcomingMatchesResponse(matchData)}\\n\\n💡 Try asking about specific matches from the list above!`;\n        }\n      }\n\n      // Check if API key is available for OpenAI fallback\n      if (!this.apiKey) {\n        return \"I'm currently experiencing technical difficulties connecting to my analysis engine. Please try asking about specific teams, leagues, or matches and I'll do my best to help with the information I have available.\";\n      }\n\n      // Create system prompt with current data for OpenAI\n      const systemPrompt = this.createSystemPrompt(matchData, leagueData);\n\n      // Call OpenAI API for general queries\n      const response = await axios.post(this.baseUrl, {\n        model: 'gpt-3.5-turbo',\n        messages: [{\n          role: 'system',\n          content: systemPrompt\n        }, {\n          role: 'user',\n          content: message\n        }],\n        max_tokens: 500,\n        temperature: 0.7\n      }, {\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        timeout: 10000\n      });\n      if ((_response$data = response.data) !== null && _response$data !== void 0 && (_response$data$choice = _response$data.choices) !== null && _response$data$choice !== void 0 && (_response$data$choice2 = _response$data$choice[0]) !== null && _response$data$choice2 !== void 0 && (_response$data$choice3 = _response$data$choice2.message) !== null && _response$data$choice3 !== void 0 && _response$data$choice3.content) {\n        return response.data.choices[0].message.content.trim();\n      }\n      throw new Error('Invalid response from AI service');\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error('Chat service error:', error);\n\n      // Handle specific error cases\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        return \"I'm having trouble accessing my analysis engine. Please try asking about specific soccer topics like team performance, upcoming matches, or league statistics, and I'll help with the information available.\";\n      }\n      if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) {\n        return \"I'm currently handling a lot of requests. Please wait a moment and try again. In the meantime, feel free to ask about specific teams or matches!\";\n      }\n      if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {\n        return \"My response is taking longer than usual. Could you try rephrasing your question about soccer analytics or asking about a specific team or league?\";\n      }\n\n      // Enhanced fallback responses with real data when OpenAI fails\n      const messageLower = message.toLowerCase();\n\n      // Get fresh match data for fallback responses\n      const [fallbackMatchData] = await Promise.all([this.getRecentMatchData()]); // Try dynamic match search for fallback responses\n      const teamNamePatterns = [\n      // VS style patterns\n      /(\\w+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+)/gi, /(\\w+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+[\\s\\w]+)/gi, /(\\w+[\\s\\w]+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+)/gi, /(\\w+[\\s\\w]+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+[\\s\\w]+)/gi,\n      // Match/game/analysis style patterns\n      /(\\w+)\\s+(\\w+)(?:\\s+match|\\s+game|\\s+analysis)/gi,\n      // Between patterns\n      /(?:match|game)\\s+(?:between\\s+)?(\\w+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+)/gi];\n      let searchTerms = [];\n      for (const pattern of teamNamePatterns) {\n        const matches = [...message.matchAll(pattern)];\n        if (matches.length > 0) {\n          const team1 = matches[0][1].trim();\n          const team2 = matches[0][2].trim();\n          if (this.isValidTeamName(team1) && this.isValidTeamName(team2)) {\n            searchTerms = [team1, team2];\n            break;\n          }\n        }\n      }\n\n      // Also check for common team names\n      if (searchTerms.length < 2) {\n        const commonTeams = ['spain', 'france', 'england', 'germany', 'brazil', 'argentina', 'portugal', 'italy', 'netherlands', 'belgium', 'croatia', 'uruguay', 'manchester united', 'manchester city', 'liverpool', 'chelsea', 'arsenal', 'tottenham', 'barcelona', 'real madrid', 'atletico madrid', 'bayern munich', 'borussia dortmund', 'psg', 'juventus', 'ac milan', 'inter milan', 'napoli', 'ajax', 'benfica', 'porto'];\n        const foundTeams = commonTeams.filter(team => messageLower.includes(team.toLowerCase()));\n        if (foundTeams.length >= 2) {\n          searchTerms = foundTeams.slice(0, 2);\n        } else if (foundTeams.length === 1 && searchTerms.length === 1 && searchTerms[0] !== foundTeams[0]) {\n          searchTerms.push(foundTeams[0]);\n        } else if (foundTeams.length === 1 && searchTerms.length === 0) {\n          searchTerms = [foundTeams[0]];\n        }\n      }\n      if (searchTerms.length > 0) {\n        const foundMatch = await this.findMatchDynamically(searchTerms);\n        if (foundMatch) {\n          const detailedData = foundMatch.id ? await this.getDetailedMatchAnalysis(foundMatch.id) : null;\n          return this.formatComprehensiveMatchAnalysis(foundMatch, detailedData);\n        }\n      }\n\n      // Specific query patterns for fallback\n      if (messageLower.includes('live') || messageLower.includes('going live') || messageLower.includes('now')) {\n        return this.formatLiveMatchesResponse(fallbackMatchData);\n      }\n      if (messageLower.includes('upcoming') || messageLower.includes('today') || messageLower.includes('tomorrow') || messageLower.includes('best matches')) {\n        return this.formatUpcomingMatchesResponse(fallbackMatchData);\n      }\n      if (messageLower.includes('bet') || messageLower.includes('odds') || messageLower.includes('prediction')) {\n        return this.formatBettingInsightsResponse(fallbackMatchData);\n      }\n\n      // Legacy specific match checks (enhanced)\n      if (messageLower.includes('spain') && messageLower.includes('france')) {\n        return this.formatSpecificMatchResponse(fallbackMatchData, 'spain', 'france');\n      }\n      if (messageLower.includes('france') && messageLower.includes('spain')) {\n        return this.formatSpecificMatchResponse(fallbackMatchData, 'france', 'spain');\n      }\n      if (messageLower.includes('hello') || messageLower.includes('hi') || messageLower.includes('hey')) {\n        return `Hello! ⚽ Welcome to Odd Genius AI!\\n\\n🔴 **Currently ${fallbackMatchData.totalLive} live matches** in progress\\n📅 **${fallbackMatchData.totalUpcoming} upcoming matches** in the next 7 days\\n\\nI can help you with:\\n🎯 **Live Match Analysis**: Get real-time insights on ongoing games\\n📊 **Upcoming Match Predictions**: Analysis with actual odds and data\\n💰 **Betting Insights**: Value bets based on current market data\\n📈 **Specific Team Analysis**: Performance insights\\n\\nTry asking:\\n• \"Show me live matches\"\\n• \"What are the best upcoming matches to bet on?\"\\n• \"Give me betting insights for today\"\\n• \"France vs Spain analysis\"\\n• \"When are matches going live?\"\\n\\nWhat would you like to explore? 🎯`;\n      }\n\n      // Enhanced general response with real data context\n      return `I'm here to help with soccer analytics using real-time data! 🚀\\n\\n📊 **Current Data Available:**\\n• ${fallbackMatchData.totalLive} live matches in progress\\n• ${fallbackMatchData.totalUpcoming} upcoming matches (next 7 days)\\n• Real odds and betting insights\\n• League analysis from active competitions\\n\\n🎯 **Try These Specific Queries:**\\n• \"Show me all live matches now\"\\n• \"What are the best matches to bet on today?\"\\n• \"Give me odds for upcoming matches\"\\n• \"France vs Spain analysis\" (or any team combination)\\n• \"Which live matches have good betting value?\"\\n• \"When do today's matches start?\"\\n\\n💡 **Tip**: I work best with specific questions about current matches, betting opportunities, or team analysis! I can analyze ANY match from the current fixtures.\\n\\nWhat soccer topic interests you most? ⚽`;\n    }\n  }\n  formatLiveMatchesResponse(matchData) {\n    if (matchData.totalLive === 0) {\n      return \"🔴 **No Live Matches Currently**\\n\\nThere are no soccer matches being played right now. Check back later for live action!\\n\\nWould you like me to show you upcoming matches instead?\";\n    }\n    const liveMatches = matchData.liveMatches.slice(0, 5);\n    let response = `🔴 **${matchData.totalLive} LIVE MATCHES NOW**\\n\\n`;\n    liveMatches.forEach((match, index) => {\n      var _match$homeTeam3, _match$score3, _match$score4, _match$awayTeam3, _match$league3;\n      response += `**${index + 1}. ${(_match$homeTeam3 = match.homeTeam) === null || _match$homeTeam3 === void 0 ? void 0 : _match$homeTeam3.name} ${(_match$score3 = match.score) === null || _match$score3 === void 0 ? void 0 : _match$score3.home} - ${(_match$score4 = match.score) === null || _match$score4 === void 0 ? void 0 : _match$score4.away} ${(_match$awayTeam3 = match.awayTeam) === null || _match$awayTeam3 === void 0 ? void 0 : _match$awayTeam3.name}**\\n`;\n      response += `   ⏱️ ${match.elapsed}' | 🏆 ${(_match$league3 = match.league) === null || _match$league3 === void 0 ? void 0 : _match$league3.name}\\n`;\n      response += `   🏟️ ${match.venue || 'Stadium TBA'}\\n`;\n      if (match.odds) {\n        response += `   💰 Odds: ${match.odds.home} / ${match.odds.draw} / ${match.odds.away}\\n`;\n      }\n      response += `\\n`;\n    });\n    if (matchData.totalLive > 5) {\n      response += `*...and ${matchData.totalLive - 5} more live matches*\\n\\n`;\n    }\n    response += \"⚡ **Live Betting Tips:**\\n\";\n    response += \"• Watch for momentum shifts in close games\\n\";\n    response += \"• Consider in-play Over/Under based on current pace\\n\";\n    response += \"• Look for red card opportunities in heated matches\\n\";\n    return response;\n  }\n  formatUpcomingMatchesResponse(matchData) {\n    if (matchData.totalUpcoming === 0) {\n      return \"📅 **No Upcoming Matches in Next 7 Days**\\n\\nThere are no soccer matches scheduled for the next week in our database.\\n\\nWould you like me to analyze current league standings or recent form instead?\";\n    }\n    const upcomingMatches = matchData.upcomingMatches.slice(0, 8);\n    let response = `📅 **UPCOMING MATCHES (Next 7 Days) - ${matchData.totalUpcoming} Total**\\n\\n`;\n    upcomingMatches.forEach((match, index) => {\n      var _match$homeTeam4, _match$awayTeam4, _match$league4;\n      response += `**${index + 1}. ${(_match$homeTeam4 = match.homeTeam) === null || _match$homeTeam4 === void 0 ? void 0 : _match$homeTeam4.name} vs ${(_match$awayTeam4 = match.awayTeam) === null || _match$awayTeam4 === void 0 ? void 0 : _match$awayTeam4.name}**\\n`;\n      response += `   📅 ${match.date} at ${match.time}\\n`;\n      response += `   🏆 ${(_match$league4 = match.league) === null || _match$league4 === void 0 ? void 0 : _match$league4.name}\\n`;\n      response += `   🏟️ ${match.venue || 'Venue TBA'}\\n`;\n      if (match.odds) {\n        var _match$probability, _match$probability2, _match$probability3;\n        response += `   💰 Odds: Home ${match.odds.home} | Draw ${match.odds.draw} | Away ${match.odds.away}\\n`;\n        response += `   📊 Probability: ${(_match$probability = match.probability) === null || _match$probability === void 0 ? void 0 : _match$probability.home} / ${(_match$probability2 = match.probability) === null || _match$probability2 === void 0 ? void 0 : _match$probability2.draw} / ${(_match$probability3 = match.probability) === null || _match$probability3 === void 0 ? void 0 : _match$probability3.away}\\n`;\n      }\n      if (match.recommended) {\n        response += `   ⭐ Recommended: ${match.recommended.toUpperCase()}\\n`;\n      }\n      response += `\\n`;\n    });\n    if (matchData.totalUpcoming > 8) {\n      response += `*...and ${matchData.totalUpcoming - 8} more upcoming matches*\\n\\n`;\n    }\n    response += \"🎯 **Best Betting Opportunities:**\\n\";\n    const goodOddsMatches = upcomingMatches.filter(m => m.odds && (m.odds.home > 1.8 || m.odds.away > 1.8));\n    if (goodOddsMatches.length > 0) {\n      goodOddsMatches.slice(0, 3).forEach(match => {\n        var _match$homeTeam5, _match$awayTeam5;\n        response += `• **${(_match$homeTeam5 = match.homeTeam) === null || _match$homeTeam5 === void 0 ? void 0 : _match$homeTeam5.name} vs ${(_match$awayTeam5 = match.awayTeam) === null || _match$awayTeam5 === void 0 ? void 0 : _match$awayTeam5.name}** - Good value odds available\\n`;\n      });\n    }\n    return response;\n  }\n  formatBettingInsightsResponse(matchData) {\n    let response = \"💰 **SMART BETTING ANALYSIS (Based on Current Data)**\\n\\n\";\n\n    // Analyze live matches for in-play opportunities\n    if (matchData.totalLive > 0) {\n      response += \"🔴 **Live Betting Opportunities:**\\n\";\n      const liveMatches = matchData.liveMatches.slice(0, 3);\n      liveMatches.forEach(match => {\n        var _match$homeTeam6, _match$awayTeam6, _match$score5, _match$score6, _match$odds4, _match$odds5, _match$odds6;\n        response += `• **${(_match$homeTeam6 = match.homeTeam) === null || _match$homeTeam6 === void 0 ? void 0 : _match$homeTeam6.name} vs ${(_match$awayTeam6 = match.awayTeam) === null || _match$awayTeam6 === void 0 ? void 0 : _match$awayTeam6.name}** (${(_match$score5 = match.score) === null || _match$score5 === void 0 ? void 0 : _match$score5.home}-${(_match$score6 = match.score) === null || _match$score6 === void 0 ? void 0 : _match$score6.away}, ${match.elapsed}')\\n`;\n        response += `  Current odds: ${(_match$odds4 = match.odds) === null || _match$odds4 === void 0 ? void 0 : _match$odds4.home}/${(_match$odds5 = match.odds) === null || _match$odds5 === void 0 ? void 0 : _match$odds5.draw}/${(_match$odds6 = match.odds) === null || _match$odds6 === void 0 ? void 0 : _match$odds6.away}\\n`;\n      });\n      response += \"\\n\";\n    }\n\n    // Analyze upcoming matches for pre-match value\n    if (matchData.totalUpcoming > 0) {\n      response += \"📅 **Pre-Match Value Bets:**\\n\";\n      const valueMatches = matchData.upcomingMatches.filter(m => m.odds && m.recommended).slice(0, 5);\n      valueMatches.forEach(match => {\n        var _match$homeTeam7, _match$awayTeam7, _match$algorithm;\n        response += `• **${(_match$homeTeam7 = match.homeTeam) === null || _match$homeTeam7 === void 0 ? void 0 : _match$homeTeam7.name} vs ${(_match$awayTeam7 = match.awayTeam) === null || _match$awayTeam7 === void 0 ? void 0 : _match$awayTeam7.name}**\\n`;\n        response += `  📊 Recommended: ${match.recommended.toUpperCase()}\\n`;\n        response += `  💰 ${match.recommended} odds: ${match.odds[match.recommended]}\\n`;\n        response += `  📈 Algorithm confidence: ${(_match$algorithm = match.algorithm) === null || _match$algorithm === void 0 ? void 0 : _match$algorithm.confidence}%\\n\\n`;\n      });\n    }\n    response += \"⚠️ **Risk Management Reminders:**\\n\";\n    response += \"• Never bet more than 2-3% of your bankroll per match\\n\";\n    response += \"• Track your predictions vs actual outcomes\\n\";\n    response += \"• Consider team news and injuries before betting\\n\";\n    response += \"• Use the odds and probabilities shown as guidance\\n\";\n    return response;\n  }\n  formatSpecificMatchResponse(matchData, team1, team2) {\n    // Look for specific match in upcoming data with flexible matching\n    const specificMatch = matchData.upcomingMatches.find(match => {\n      var _match$homeTeam8, _match$awayTeam8;\n      const homeTeam = (((_match$homeTeam8 = match.homeTeam) === null || _match$homeTeam8 === void 0 ? void 0 : _match$homeTeam8.name) || '').toLowerCase();\n      const awayTeam = (((_match$awayTeam8 = match.awayTeam) === null || _match$awayTeam8 === void 0 ? void 0 : _match$awayTeam8.name) || '').toLowerCase();\n      const t1 = team1.toLowerCase();\n      const t2 = team2.toLowerCase();\n      return homeTeam.includes(t1) && awayTeam.includes(t2) || homeTeam.includes(t2) && awayTeam.includes(t1) || homeTeam === t1 && awayTeam === t2 || homeTeam === t2 && awayTeam === t1;\n    });\n    if (specificMatch) {\n      var _specificMatch$homeTe, _specificMatch$awayTe, _specificMatch$league, _specificMatch$league2;\n      let response = `🔍 **MATCH ANALYSIS: ${(_specificMatch$homeTe = specificMatch.homeTeam) === null || _specificMatch$homeTe === void 0 ? void 0 : _specificMatch$homeTe.name} vs ${(_specificMatch$awayTe = specificMatch.awayTeam) === null || _specificMatch$awayTe === void 0 ? void 0 : _specificMatch$awayTe.name}**\\n\\n`;\n      response += `📅 **Match Details:**\\n`;\n      response += `• Date: ${specificMatch.date}\\n`;\n      response += `• Time: ${specificMatch.time}\\n`;\n      response += `• League: ${(_specificMatch$league = specificMatch.league) === null || _specificMatch$league === void 0 ? void 0 : _specificMatch$league.name}\\n`;\n      response += `• Venue: ${specificMatch.venue || 'TBA'}\\n\\n`;\n      if (specificMatch.odds) {\n        var _specificMatch$homeTe2, _specificMatch$awayTe2, _specificMatch$probab, _specificMatch$probab2, _specificMatch$probab3;\n        response += `💰 **Betting Odds:**\\n`;\n        response += `• Home Win (${(_specificMatch$homeTe2 = specificMatch.homeTeam) === null || _specificMatch$homeTe2 === void 0 ? void 0 : _specificMatch$homeTe2.name}): ${specificMatch.odds.home}\\n`;\n        response += `• Draw: ${specificMatch.odds.draw}\\n`;\n        response += `• Away Win (${(_specificMatch$awayTe2 = specificMatch.awayTeam) === null || _specificMatch$awayTe2 === void 0 ? void 0 : _specificMatch$awayTe2.name}): ${specificMatch.odds.away}\\n\\n`;\n        response += `📊 **Probabilities:**\\n`;\n        response += `• Home: ${(_specificMatch$probab = specificMatch.probability) === null || _specificMatch$probab === void 0 ? void 0 : _specificMatch$probab.home}\\n`;\n        response += `• Draw: ${(_specificMatch$probab2 = specificMatch.probability) === null || _specificMatch$probab2 === void 0 ? void 0 : _specificMatch$probab2.draw}\\n`;\n        response += `• Away: ${(_specificMatch$probab3 = specificMatch.probability) === null || _specificMatch$probab3 === void 0 ? void 0 : _specificMatch$probab3.away}\\n\\n`;\n      }\n      if (specificMatch.recommended) {\n        var _specificMatch$algori;\n        response += `⭐ **Our Algorithm Recommends:** ${specificMatch.recommended.toUpperCase()}\\n`;\n        response += `🎯 **Confidence Level:** ${(_specificMatch$algori = specificMatch.algorithm) === null || _specificMatch$algori === void 0 ? void 0 : _specificMatch$algori.confidence}%\\n\\n`;\n      }\n      response += `🎲 **Betting Markets Analysis:**\\n`;\n      response += `• **1X2 Market**: ${specificMatch.recommended ? `Consider ${specificMatch.recommended.toUpperCase()} (${specificMatch.odds[specificMatch.recommended]} odds)` : 'Analyze team form'}\\n`;\n      response += `• **Over/Under Goals**: With teams like these, consider Over 2.5 goals\\n`;\n      response += `• **Both Teams to Score**: High-quality attacking teams suggest BTTS Yes\\n`;\n      response += `• **Corners**: Possession-based teams typically generate more corner opportunities\\n\\n`;\n      response += `📈 **Recent Form Context:**\\n`;\n      response += `• Both teams are top-tier international sides\\n`;\n      response += `• ${(_specificMatch$league2 = specificMatch.league) === null || _specificMatch$league2 === void 0 ? void 0 : _specificMatch$league2.name} - high-stakes competition\\n`;\n      response += `• Historical matchups between these teams are often tight\\n`;\n      response += `• Consider current squad form and injuries before betting\\n`;\n      return response;\n    }\n    return `🔍 I couldn't find a specific match between ${team1} and ${team2} in the upcoming fixtures (next 7 days).\\n\\n📅 **Current Upcoming Matches:**\\n${this.formatUpcomingMatchesResponse(matchData)}`;\n  }\n  async findMatchDynamically(searchTerms) {\n    try {\n      const [matchData] = await Promise.all([this.getRecentMatchData()]);\n      const allMatches = [...(Array.isArray(matchData.liveMatches) ? matchData.liveMatches : []), ...(Array.isArray(matchData.upcomingMatches) ? matchData.upcomingMatches : [])];\n      if (allMatches.length === 0) {\n        console.log('No matches available for dynamic search');\n        return null;\n      }\n\n      // Get all team names from matches\n      const allTeamNames = new Set();\n      allMatches.forEach(match => {\n        var _match$homeTeam9, _match$awayTeam9;\n        if ((_match$homeTeam9 = match.homeTeam) !== null && _match$homeTeam9 !== void 0 && _match$homeTeam9.name) allTeamNames.add(match.homeTeam.name);\n        if ((_match$awayTeam9 = match.awayTeam) !== null && _match$awayTeam9 !== void 0 && _match$awayTeam9.name) allTeamNames.add(match.awayTeam.name);\n      });\n\n      // Find best matches for both search terms\n      const team1Match = this.findBestMatch(searchTerms[0], Array.from(allTeamNames));\n      const team2Match = searchTerms[1] ? this.findBestMatch(searchTerms[1], Array.from(allTeamNames)) : null;\n      if (!team1Match || searchTerms[1] && !team2Match) {\n        return null;\n      }\n\n      // Look for a match with these teams\n      return allMatches.find(match => {\n        var _match$homeTeam0, _match$awayTeam0;\n        const homeTeam = (_match$homeTeam0 = match.homeTeam) === null || _match$homeTeam0 === void 0 ? void 0 : _match$homeTeam0.name;\n        const awayTeam = (_match$awayTeam0 = match.awayTeam) === null || _match$awayTeam0 === void 0 ? void 0 : _match$awayTeam0.name;\n        return homeTeam === team1Match && awayTeam === team2Match || homeTeam === team2Match && awayTeam === team1Match;\n      });\n    } catch (error) {\n      console.error('Error in findMatchDynamically:', error);\n      return null;\n    }\n  }\n  calculateSimilarity(term1, term2) {\n    // Convert both terms to lowercase for comparison\n    const s1 = term1.toLowerCase();\n    const s2 = term2.toLowerCase();\n\n    // Quick exact match check\n    if (s1 === s2) return 1;\n\n    // Handle one term containing the other\n    if (s1.includes(s2) || s2.includes(s1)) return 0.9;\n\n    // Calculate Levenshtein distance\n    const distance = this.levenshteinDistance(s1, s2);\n    const maxLength = Math.max(s1.length, s2.length);\n\n    // Convert distance to similarity score (0-1)\n    return 1 - distance / maxLength;\n  }\n  levenshteinDistance(str1, str2) {\n    const m = str1.length;\n    const n = str2.length;\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (str1[i - 1] === str2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = Math.min(dp[i - 1][j - 1] + 1,\n          // substitution\n          dp[i - 1][j] + 1,\n          // deletion\n          dp[i][j - 1] + 1 // insertion\n          );\n        }\n      }\n    }\n    return dp[m][n];\n  }\n  normalizeTeamName(name) {\n    return name.toLowerCase().replace(/\\s+/g, ' ').trim().replace(/fc$/, '').replace(/united$/, 'utd').replace(/[^\\w\\s]/g, '');\n  }\n  findBestMatch(searchTerm, candidates) {\n    const normalizedSearch = this.normalizeTeamName(searchTerm);\n    let bestMatch = null;\n    let bestScore = 0;\n    for (const candidate of candidates) {\n      const normalizedCandidate = this.normalizeTeamName(candidate);\n      const score = this.calculateSimilarity(normalizedSearch, normalizedCandidate);\n\n      // Adjust threshold based on term length\n      const threshold = normalizedSearch.length <= 4 ? 0.85 : 0.7;\n      if (score > bestScore && score >= threshold) {\n        bestScore = score;\n        bestMatch = candidate;\n      }\n    }\n    return bestMatch;\n  }\n  async getDetailedMatchAnalysis(matchId) {\n    try {\n      var _matchDetails$data, _h2h$data, _corners$data, _btts$data, _cards$data, _analysis$data, _matchData$homeTeam, _matchData$awayTeam;\n      const baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\n\n      // Get comprehensive match data\n      const [matchDetails, h2h, corners, btts, cards, analysis] = await Promise.all([axios.get(`${baseUrl}/matches/${matchId}`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/h2h`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/corners`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/btts`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/cards`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/analysis`).catch(() => ({\n        data: null\n      }))]);\n\n      // Extract data, handling the possible nested 'result' structure\n      const matchData = ((_matchDetails$data = matchDetails.data) === null || _matchDetails$data === void 0 ? void 0 : _matchDetails$data.result) || matchDetails.data;\n      const h2hData = ((_h2h$data = h2h.data) === null || _h2h$data === void 0 ? void 0 : _h2h$data.result) || h2h.data;\n      const cornersData = ((_corners$data = corners.data) === null || _corners$data === void 0 ? void 0 : _corners$data.result) || corners.data;\n      const bttsData = ((_btts$data = btts.data) === null || _btts$data === void 0 ? void 0 : _btts$data.result) || btts.data;\n      const cardsData = ((_cards$data = cards.data) === null || _cards$data === void 0 ? void 0 : _cards$data.result) || cards.data;\n      const analysisData = ((_analysis$data = analysis.data) === null || _analysis$data === void 0 ? void 0 : _analysis$data.result) || analysis.data;\n\n      // Get team form if we have team IDs\n      let teamForm = {\n        home: null,\n        away: null\n      };\n      if (matchData !== null && matchData !== void 0 && (_matchData$homeTeam = matchData.homeTeam) !== null && _matchData$homeTeam !== void 0 && _matchData$homeTeam.id && matchData !== null && matchData !== void 0 && (_matchData$awayTeam = matchData.awayTeam) !== null && _matchData$awayTeam !== void 0 && _matchData$awayTeam.id) {\n        var _homeForm$data, _awayForm$data;\n        const [homeForm, awayForm] = await Promise.all([axios.get(`${baseUrl}/teams/${matchData.homeTeam.id}/form`).catch(() => ({\n          data: null\n        })), axios.get(`${baseUrl}/teams/${matchData.awayTeam.id}/form`).catch(() => ({\n          data: null\n        }))]);\n        teamForm = {\n          home: ((_homeForm$data = homeForm.data) === null || _homeForm$data === void 0 ? void 0 : _homeForm$data.result) || homeForm.data,\n          away: ((_awayForm$data = awayForm.data) === null || _awayForm$data === void 0 ? void 0 : _awayForm$data.result) || awayForm.data\n        };\n      }\n      return {\n        matchDetails: matchData,\n        h2h: h2hData,\n        corners: cornersData,\n        btts: bttsData,\n        cards: cardsData,\n        analysis: analysisData,\n        teamForm\n      };\n    } catch (error) {\n      console.error('Error getting detailed match analysis:', error);\n      return null;\n    }\n  }\n  formatComprehensiveMatchAnalysis(match, detailedData) {\n    var _match$homeTeam1, _match$awayTeam1, _match$league5, _detailedData$btts, _detailedData$btts$re, _detailedData$btts2, _detailedData$btts2$r, _detailedData$corners, _detailedData$corners2, _detailedData$cards, _detailedData$cards$p;\n    let response = `🔍 **COMPREHENSIVE MATCH ANALYSIS**\\n`;\n    response += `**${(_match$homeTeam1 = match.homeTeam) === null || _match$homeTeam1 === void 0 ? void 0 : _match$homeTeam1.name} vs ${(_match$awayTeam1 = match.awayTeam) === null || _match$awayTeam1 === void 0 ? void 0 : _match$awayTeam1.name}**\\n\\n`;\n\n    // Basic match info\n    response += `📅 **Match Details:**\\n`;\n    response += `• Date: ${match.date} at ${match.time}\\n`;\n    response += `• League: ${(_match$league5 = match.league) === null || _match$league5 === void 0 ? void 0 : _match$league5.name}\\n`;\n    response += `• Venue: ${match.venue || 'TBA'}\\n`;\n    if (match.status === 'LIVE') {\n      var _match$score7, _match$score8;\n      response += `• Status: 🔴 LIVE (${match.elapsed}')\\n`;\n      response += `• Current Score: ${(_match$score7 = match.score) === null || _match$score7 === void 0 ? void 0 : _match$score7.home} - ${(_match$score8 = match.score) === null || _match$score8 === void 0 ? void 0 : _match$score8.away}\\n`;\n    }\n    response += `\\n`;\n\n    // Betting odds and recommendations\n    if (match.odds) {\n      var _match$homeTeam10, _match$awayTeam10;\n      response += `💰 **Betting Analysis:**\\n`;\n      response += `• Home Win (${(_match$homeTeam10 = match.homeTeam) === null || _match$homeTeam10 === void 0 ? void 0 : _match$homeTeam10.name}): ${match.odds.home}\\n`;\n      response += `• Draw: ${match.odds.draw}\\n`;\n      response += `• Away Win (${(_match$awayTeam10 = match.awayTeam) === null || _match$awayTeam10 === void 0 ? void 0 : _match$awayTeam10.name}): ${match.odds.away}\\n`;\n      if (match.probability) {\n        response += `• Probabilities: ${match.probability.home} / ${match.probability.draw} / ${match.probability.away}\\n`;\n      }\n      if (match.recommended) {\n        var _match$algorithm2;\n        response += `• ⭐ **Recommended Bet**: ${match.recommended.toUpperCase()}\\n`;\n        response += `• 🎯 **Confidence**: ${(_match$algorithm2 = match.algorithm) === null || _match$algorithm2 === void 0 ? void 0 : _match$algorithm2.confidence}%\\n`;\n      }\n      response += `\\n`;\n    }\n\n    // Detailed analysis from backend\n    if (detailedData) {\n      // Team Form\n      if (detailedData.teamForm.home || detailedData.teamForm.away) {\n        response += `📈 **Recent Team Form:**\\n`;\n        if (detailedData.teamForm.home) {\n          var _match$homeTeam11;\n          const homeForm = detailedData.teamForm.home;\n          response += `• **${(_match$homeTeam11 = match.homeTeam) === null || _match$homeTeam11 === void 0 ? void 0 : _match$homeTeam11.name}**: ${homeForm.recentForm || ''}\\n`;\n          if (homeForm.lastMatches) {\n            const lastResults = Array.isArray(homeForm.lastMatches) ? homeForm.lastMatches.slice(0, 5).map(m => `${m.result || m.outcome || '?'} vs ${m.opponent || 'Unknown'}`).join(', ') : 'Recent matches data available';\n            response += `  Last 5: ${lastResults}\\n`;\n          }\n          if (homeForm.stats) {\n            response += `  Goals scored/conceded: ${homeForm.stats.goalsScored || '?'}/${homeForm.stats.goalsConceded || '?'}\\n`;\n          }\n        }\n        if (detailedData.teamForm.away) {\n          var _match$awayTeam11;\n          const awayForm = detailedData.teamForm.away;\n          response += `• **${(_match$awayTeam11 = match.awayTeam) === null || _match$awayTeam11 === void 0 ? void 0 : _match$awayTeam11.name}**: ${awayForm.recentForm || ''}\\n`;\n          if (awayForm.lastMatches) {\n            const lastResults = Array.isArray(awayForm.lastMatches) ? awayForm.lastMatches.slice(0, 5).map(m => `${m.result || m.outcome || '?'} vs ${m.opponent || 'Unknown'}`).join(', ') : 'Recent matches data available';\n            response += `  Last 5: ${lastResults}\\n`;\n          }\n          if (awayForm.stats) {\n            response += `  Goals scored/conceded: ${awayForm.stats.goalsScored || '?'}/${awayForm.stats.goalsConceded || '?'}\\n`;\n          }\n        }\n        response += `\\n`;\n      }\n\n      // Head-to-Head\n      if (detailedData.h2h) {\n        response += `🏆 **Head-to-Head Record:**\\n`;\n        if (Array.isArray(detailedData.h2h)) {\n          var _match$homeTeam14, _match$awayTeam14;\n          const totalMatches = detailedData.h2h.length;\n          const homeWins = detailedData.h2h.filter(m => {\n            var _match$homeTeam12, _match$homeTeam13;\n            return m.winner === ((_match$homeTeam12 = match.homeTeam) === null || _match$homeTeam12 === void 0 ? void 0 : _match$homeTeam12.name) || m.winner === ((_match$homeTeam13 = match.homeTeam) === null || _match$homeTeam13 === void 0 ? void 0 : _match$homeTeam13.id);\n          }).length;\n          const awayWins = detailedData.h2h.filter(m => {\n            var _match$awayTeam12, _match$awayTeam13;\n            return m.winner === ((_match$awayTeam12 = match.awayTeam) === null || _match$awayTeam12 === void 0 ? void 0 : _match$awayTeam12.name) || m.winner === ((_match$awayTeam13 = match.awayTeam) === null || _match$awayTeam13 === void 0 ? void 0 : _match$awayTeam13.id);\n          }).length;\n          const draws = detailedData.h2h.filter(m => m.winner === 'draw' || m.result === 'draw').length;\n          response += `• Last ${totalMatches} meetings: ${(_match$homeTeam14 = match.homeTeam) === null || _match$homeTeam14 === void 0 ? void 0 : _match$homeTeam14.name} won ${homeWins}, ${(_match$awayTeam14 = match.awayTeam) === null || _match$awayTeam14 === void 0 ? void 0 : _match$awayTeam14.name} won ${awayWins}, Draws: ${draws}\\n`;\n          const recentMatches = detailedData.h2h.slice(0, 3);\n          if (recentMatches.length > 0) {\n            response += `• Recent results:\\n`;\n            recentMatches.forEach(m => {\n              response += `  ${m.date || 'Unknown date'}: ${m.homeTeam || '?'} ${m.homeScore || '?'}-${m.awayScore || '?'} ${m.awayTeam || '?'}\\n`;\n            });\n          }\n        } else {\n          response += `• Historical performance data available\\n`;\n          response += `• Statistical trends and patterns analyzed\\n`;\n        }\n        response += `\\n`;\n      }\n\n      // Corners Analysis\n      if (detailedData.corners) {\n        var _match$homeTeam15;\n        response += `🚩 **Corners Analysis:**\\n`;\n        const corners = detailedData.corners;\n        if (corners.cornerStats) {\n          var _corners$cornerStats$, _corners$cornerStats$2;\n          response += `• **Average Corners:** ${corners.cornerStats.avgTotal || '?'} per match\\n`;\n          response += `• **Home Team Avg:** ${((_corners$cornerStats$ = corners.cornerStats.home) === null || _corners$cornerStats$ === void 0 ? void 0 : _corners$cornerStats$.avg) || '?'} per match\\n`;\n          response += `• **Away Team Avg:** ${((_corners$cornerStats$2 = corners.cornerStats.away) === null || _corners$cornerStats$2 === void 0 ? void 0 : _corners$cornerStats$2.avg) || '?'} per match\\n`;\n        }\n        if (corners.prediction) {\n          response += `• **Prediction:** ${corners.prediction.total || 'Under analysis'}\\n`;\n          response += `• **Over/Under 9.5:** ${corners.prediction.over9_5 ? 'Over looks likely' : 'Under looks likely'}\\n`;\n        }\n        response += `• **Corner Patterns:** Team tactical approaches indicate ${(_match$homeTeam15 = match.homeTeam) === null || _match$homeTeam15 === void 0 ? void 0 : _match$homeTeam15.name} ${corners.homeAttacking ? 'is more attacking' : 'tends to defend more'}\\n`;\n        response += `\\n`;\n      }\n\n      // Goals Analysis (BTTS)\n      if (detailedData.btts) {\n        var _match$homeTeam16, _btts$goalTiming, _match$awayTeam15, _btts$goalTiming2;\n        response += `⚽ **Goals Analysis:**\\n`;\n        const btts = detailedData.btts;\n        if (btts.bttsStats) {\n          response += `• **Both Teams to Score:** ${btts.bttsStats.bttsRate || btts.bttsStats.rate || '?'}% probability\\n`;\n          response += `• **Over 2.5 Goals:** ${btts.bttsStats.over25Rate || btts.bttsStats.o25Rate || '?'}% probability\\n`;\n        }\n        if (btts.recommendation) {\n          response += `• **BTTS Recommendation:** ${btts.recommendation.btts || 'Under analysis'}\\n`;\n          response += `• **O/U Recommendation:** ${btts.recommendation.overUnder || 'Under analysis'}\\n`;\n        }\n        response += `• **Goal Timing:** ${(_match$homeTeam16 = match.homeTeam) === null || _match$homeTeam16 === void 0 ? void 0 : _match$homeTeam16.name} tends to score ${((_btts$goalTiming = btts.goalTiming) === null || _btts$goalTiming === void 0 ? void 0 : _btts$goalTiming.home) || 'throughout the match'}\\n`;\n        response += `• **Goal Timing:** ${(_match$awayTeam15 = match.awayTeam) === null || _match$awayTeam15 === void 0 ? void 0 : _match$awayTeam15.name} tends to score ${((_btts$goalTiming2 = btts.goalTiming) === null || _btts$goalTiming2 === void 0 ? void 0 : _btts$goalTiming2.away) || 'throughout the match'}\\n`;\n        response += `\\n`;\n      }\n\n      // Cards Analysis\n      if (detailedData.cards) {\n        response += `🟨 **Cards Analysis:**\\n`;\n        const cards = detailedData.cards;\n        if (cards.cardStats) {\n          var _match$homeTeam17, _cards$cardStats$home, _match$awayTeam16, _cards$cardStats$away;\n          response += `• **Average Cards:** ${cards.cardStats.avgTotal || '?'} per match\\n`;\n          response += `• **${(_match$homeTeam17 = match.homeTeam) === null || _match$homeTeam17 === void 0 ? void 0 : _match$homeTeam17.name} Avg:** ${((_cards$cardStats$home = cards.cardStats.home) === null || _cards$cardStats$home === void 0 ? void 0 : _cards$cardStats$home.avg) || '?'} cards\\n`;\n          response += `• **${(_match$awayTeam16 = match.awayTeam) === null || _match$awayTeam16 === void 0 ? void 0 : _match$awayTeam16.name} Avg:** ${((_cards$cardStats$away = cards.cardStats.away) === null || _cards$cardStats$away === void 0 ? void 0 : _cards$cardStats$away.avg) || '?'} cards\\n`;\n        }\n        if (cards.prediction) {\n          response += `• **Cards Prediction:** ${cards.prediction.total || 'Under analysis'}\\n`;\n          response += `• **Over/Under 3.5:** ${cards.prediction.over3_5 ? 'Over looks likely' : 'Under looks likely'}\\n`;\n        }\n        if (cards.referee) {\n          response += `• **Referee:** ${cards.referee.name || 'TBA'} - Avg ${cards.referee.cardsPerMatch || '?'} cards per match\\n`;\n        }\n        response += `\\n`;\n      }\n    }\n\n    // Strategic insights\n    response += `🎯 **Key Betting Markets:**\\n`;\n    response += `• **1X2 Market**: ${match.recommended ? `Consider ${match.recommended.toUpperCase()}` : 'Analyze odds value'}\\n`;\n    response += `• **Over/Under Goals**: ${(detailedData === null || detailedData === void 0 ? void 0 : (_detailedData$btts = detailedData.btts) === null || _detailedData$btts === void 0 ? void 0 : (_detailedData$btts$re = _detailedData$btts.recommendation) === null || _detailedData$btts$re === void 0 ? void 0 : _detailedData$btts$re.overUnder) || 'Check team scoring averages and defensive records'}\\n`;\n    response += `• **Both Teams to Score**: ${(detailedData === null || detailedData === void 0 ? void 0 : (_detailedData$btts2 = detailedData.btts) === null || _detailedData$btts2 === void 0 ? void 0 : (_detailedData$btts2$r = _detailedData$btts2.recommendation) === null || _detailedData$btts2$r === void 0 ? void 0 : _detailedData$btts2$r.btts) || 'Evaluate attacking strength vs defensive weaknesses'}\\n`;\n    response += `• **Corners**: ${(detailedData === null || detailedData === void 0 ? void 0 : (_detailedData$corners = detailedData.corners) === null || _detailedData$corners === void 0 ? void 0 : (_detailedData$corners2 = _detailedData$corners.prediction) === null || _detailedData$corners2 === void 0 ? void 0 : _detailedData$corners2.recommendation) || 'Consider playing styles (possession vs counter-attack)'}\\n`;\n    response += `• **Cards**: ${(detailedData === null || detailedData === void 0 ? void 0 : (_detailedData$cards = detailedData.cards) === null || _detailedData$cards === void 0 ? void 0 : (_detailedData$cards$p = _detailedData$cards.prediction) === null || _detailedData$cards$p === void 0 ? void 0 : _detailedData$cards$p.recommendation) || 'Factor in referee strictness and team discipline records'}\\n\\n`;\n    response += `⚠️ **Risk Considerations:**\\n`;\n    response += `• Team news and injuries (check latest updates)\\n`;\n    response += `• Weather conditions and pitch quality\\n`;\n    response += `• Motivation levels (tournament importance, league position)\\n`;\n    response += `• Recent form momentum and confidence\\n`;\n    return response;\n  }\n  isValidTeamName(name) {\n    if (!name || name.length < 2) return false;\n\n    // Filter out common words that might be mistaken for team names\n    const commonWords = ['match', 'game', 'team', 'versus', 'against', 'between', 'analysis', 'statistics', 'odds', 'betting', 'prediction', 'today', 'tomorrow', 'yesterday', 'please', 'thanks', 'give', 'show', 'tell', 'about', 'what', 'when', 'where', 'who', 'why', 'how', 'the', 'and', 'for'];\n    const normalizedName = this.normalizeTeamName(name);\n    if (commonWords.includes(normalizedName)) {\n      return false;\n    }\n\n    // Check that the name doesn't contain common question words or phrases\n    const questionPhrases = ['what is', 'how to', 'can you', 'will you', 'should i', 'do you'];\n    for (const phrase of questionPhrases) {\n      if (normalizedName.includes(phrase)) {\n        return false;\n      }\n    }\n\n    // Check if it's likely a team name by checking for common team name patterns\n    const teamPatterns = [/^[a-z]+$/i,\n    // Single word (e.g., Arsenal)\n    /^[a-z]+\\s+[a-z]+$/i,\n    // Two words (e.g., Real Madrid)\n    /^[a-z]+\\s+[a-z]+\\s+[a-z]+$/i,\n    // Three words (e.g., Red Bull Leipzig)\n    /^[a-z\\s\\-]+$/i,\n    // Words with hyphens (e.g., Wolverhampton Wanderers)\n    /^[a-z\\s\\.]+$/i // Words with periods (e.g., F.C. Barcelona)\n    ];\n    return teamPatterns.some(pattern => pattern.test(name));\n  }\n}\nexport const chatService = new ChatService();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}