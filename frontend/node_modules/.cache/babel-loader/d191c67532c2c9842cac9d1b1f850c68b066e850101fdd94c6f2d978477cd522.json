{"ast":null,"code":"import axios from 'axios';\nimport soccerApiService from '../api/soccerApiService';\nclass ChatService {\n  constructor() {\n    this.apiKey = void 0;\n    this.baseUrl = void 0;\n    this.apiKey = process.env.REACT_APP_OPENAI_API_KEY || '';\n    this.baseUrl = 'https://api.openai.com/v1/chat/completions';\n  }\n  isValidSoccerQuery(message) {\n    const soccerKeywords = ['soccer', 'football', 'match', 'team', 'league', 'goal', 'score', 'bet', 'odds', 'statistics', 'analysis', 'prediction', 'premier league', 'champions league', 'la liga', 'serie a', 'bundesliga', 'ligue 1', 'mls', 'world cup', 'euro', 'player', 'coach', 'transfer', 'formation', 'tactics', 'expected goals', 'xg', 'xa', 'possession', 'shots', 'corners', 'cards', 'fouls', 'offside', 'penalty', 'free kick', 'striker', 'midfielder', 'defender', 'goalkeeper', 'arsenal', 'manchester', 'liverpool', 'chelsea', 'barcelona', 'real madrid', 'juventus', 'milan', 'bayern', 'psg', 'atletico', 'tottenham', 'city'];\n    const messageLower = message.toLowerCase();\n    return soccerKeywords.some(keyword => messageLower.includes(keyword));\n  }\n  async getRecentMatchData() {\n    try {\n      // Get live and upcoming matches\n      const [liveMatches, upcomingMatches] = await Promise.all([soccerApiService.getLiveMatches().catch(() => ({\n        result: []\n      })), soccerApiService.getUpcomingMatches().catch(() => ({\n        result: []\n      }))]);\n      const liveData = (liveMatches === null || liveMatches === void 0 ? void 0 : liveMatches.result) || liveMatches || [];\n      const upcomingData = (upcomingMatches === null || upcomingMatches === void 0 ? void 0 : upcomingMatches.result) || upcomingMatches || [];\n\n      // Get next 7 days of matches\n      const now = new Date();\n      const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);\n      const recentMatches = Array.isArray(upcomingData) ? upcomingData.filter(match => {\n        const matchDate = new Date(`${match.date} ${match.time}`);\n        return matchDate >= now && matchDate <= nextWeek;\n      }).slice(0, 20) : [];\n      return {\n        liveMatches: Array.isArray(liveData) ? liveData.slice(0, 10) : [],\n        upcomingMatches: recentMatches,\n        totalLive: Array.isArray(liveData) ? liveData.length : 0,\n        totalUpcoming: recentMatches.length,\n        rawLiveData: liveData,\n        rawUpcomingData: upcomingData\n      };\n    } catch (error) {\n      console.error('Error fetching match data:', error);\n      return {\n        liveMatches: [],\n        upcomingMatches: [],\n        totalLive: 0,\n        totalUpcoming: 0,\n        rawLiveData: [],\n        rawUpcomingData: []\n      };\n    }\n  }\n  async getLeagueData() {\n    try {\n      // Get popular leagues data if available\n      const leagues = ['Premier League', 'Champions League', 'La Liga', 'Serie A', 'Bundesliga', 'Ligue 1'];\n      return {\n        availableLeagues: leagues,\n        note: \"I can provide analysis for major European leagues and competitions\"\n      };\n    } catch (error) {\n      console.error('Error fetching league data:', error);\n      return {\n        availableLeagues: [],\n        note: \"League data temporarily unavailable\"\n      };\n    }\n  }\n  createSystemPrompt(matchData, leagueData) {\n    const liveMatchesInfo = matchData.liveMatches.map(match => {\n      var _match$homeTeam, _match$awayTeam, _match$score, _match$score2, _match$league;\n      return `${(_match$homeTeam = match.homeTeam) === null || _match$homeTeam === void 0 ? void 0 : _match$homeTeam.name} vs ${(_match$awayTeam = match.awayTeam) === null || _match$awayTeam === void 0 ? void 0 : _match$awayTeam.name} (${(_match$score = match.score) === null || _match$score === void 0 ? void 0 : _match$score.home}-${(_match$score2 = match.score) === null || _match$score2 === void 0 ? void 0 : _match$score2.away}, ${match.elapsed}', League: ${(_match$league = match.league) === null || _match$league === void 0 ? void 0 : _match$league.name})`;\n    }).slice(0, 5).join(', ');\n    const upcomingMatchesInfo = matchData.upcomingMatches.map(match => {\n      var _match$homeTeam2, _match$awayTeam2, _match$league2, _match$odds, _match$odds2, _match$odds3;\n      return `${(_match$homeTeam2 = match.homeTeam) === null || _match$homeTeam2 === void 0 ? void 0 : _match$homeTeam2.name} vs ${(_match$awayTeam2 = match.awayTeam) === null || _match$awayTeam2 === void 0 ? void 0 : _match$awayTeam2.name} (${match.date} ${match.time}, League: ${(_match$league2 = match.league) === null || _match$league2 === void 0 ? void 0 : _match$league2.name}, Odds: ${(_match$odds = match.odds) === null || _match$odds === void 0 ? void 0 : _match$odds.home}/${(_match$odds2 = match.odds) === null || _match$odds2 === void 0 ? void 0 : _match$odds2.draw}/${(_match$odds3 = match.odds) === null || _match$odds3 === void 0 ? void 0 : _match$odds3.away})`;\n    }).slice(0, 5).join(', ');\n    return `You are Odd Genius AI, a specialized soccer analytics assistant with access to REAL-TIME data. You help users with:\n\n**CURRENT LIVE MATCHES** (${matchData.totalLive} ongoing):\n${liveMatchesInfo || 'No live matches currently'}\n\n**UPCOMING MATCHES** (Next 7 days - ${matchData.totalUpcoming} matches):\n${upcomingMatchesInfo || 'No upcoming matches in the next 7 days'}\n\n**Your Capabilities:**\n1. **Real-Time Analysis**: Provide insights on the actual live and upcoming matches shown above\n2. **Betting Insights**: Use the real odds data (home/draw/away) for value betting recommendations\n3. **League Analysis**: Analyze patterns from the leagues currently active\n4. **Match Predictions**: Base predictions on the actual upcoming fixtures\n5. **Statistical Analysis**: Reference real team performance from current data\n\n**IMPORTANT GUIDELINES:**\n- ALWAYS use the real match data provided above when answering questions\n- When asked about \"today's matches\" or \"live matches\", reference the actual live matches listed\n- When asked about upcoming matches, use the actual upcoming fixtures provided\n- Provide specific team names, leagues, odds, and match times from the real data\n- If asked about matches not in the current data, explain that you can only analyze currently available matches\n- For betting advice, reference the actual odds shown in the data\n- NEVER make up match data - only use what's provided above\n\n**Data Context:**\n- Live matches include real scores, elapsed time, and venues\n- Upcoming matches include actual odds for home/draw/away outcomes\n- All data is current and updated in real-time\n\nRespond with specific, actionable insights based on the real match data provided.`;\n  }\n  async sendMessage(message) {\n    try {\n      var _response$data, _response$data$choice, _response$data$choice2, _response$data$choice3;\n      // Validate if the query is soccer-related\n      if (!this.isValidSoccerQuery(message)) {\n        return \"I'm your soccer analytics assistant! I can only help with soccer-related questions like match predictions, team analysis, betting insights, league statistics, and player performance. What would you like to know about soccer?\";\n      }\n\n      // Get recent soccer data first for dynamic analysis\n      const [matchData, leagueData] = await Promise.all([this.getRecentMatchData(), this.getLeagueData()]);\n\n      // ENHANCED: Check for specific match queries with dynamic search\n      const messageLower = message.toLowerCase();\n      // Extract potential team names from the message\n      const teamNamePatterns = [\n      // VS style patterns\n      /(\\w+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+)/gi, /(\\w+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+[\\s\\w]+)/gi, /(\\w+[\\s\\w]+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+)/gi, /(\\w+[\\s\\w]+)\\s+(?:vs?|x|against|versus|\\-)\\s+(\\w+[\\s\\w]+)/gi,\n      // Match/game/analysis style patterns\n      /(\\w+)\\s+(\\w+)(?:\\s+match|\\s+game|\\s+analysis)/gi, /(\\w+[\\s\\w]+)\\s+(\\w+)(?:\\s+match|\\s+game|\\s+analysis)/gi, /(\\w+)\\s+(\\w+[\\s\\w]+)(?:\\s+match|\\s+game|\\s+analysis)/gi, /(\\w+[\\s\\w]+)\\s+(\\w+[\\s\\w]+)(?:\\s+match|\\s+game|\\s+analysis)/gi,\n      // Between patterns\n      /(?:match|game)\\s+(?:between\\s+)?(\\w+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+)/gi, /(?:match|game)\\s+(?:between\\s+)?(\\w+[\\s\\w]+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+)/gi, /(?:match|game)\\s+(?:between\\s+)?(\\w+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+[\\s\\w]+)/gi, /(?:match|game)\\s+(?:between\\s+)?(\\w+[\\s\\w]+)\\s+(?:and\\s+|vs?\\s+|x\\s+)(\\w+[\\s\\w]+)/gi,\n      // Playing style patterns\n      /(\\w+[\\s\\w]*)\\s+(?:playing|plays|play|face|faces|facing)\\s+(?:against\\s+)?(\\w+[\\s\\w]*)/gi,\n      // Simple two team names separated by \"and\" patterns\n      /(?:teams|team)\\s+(\\w+[\\s\\w]*)\\s+and\\s+(\\w+[\\s\\w]*)/gi];\n      let searchTerms = [];\n\n      // Try to extract team names using the patterns\n      for (const pattern of teamNamePatterns) {\n        const matches = [...message.matchAll(pattern)];\n        if (matches.length > 0) {\n          // Clean up the extracted team names\n          const team1 = matches[0][1].trim();\n          const team2 = matches[0][2].trim();\n\n          // Validate that the extracted teams are not common words or too short\n          if (this.isValidTeamName(team1) && this.isValidTeamName(team2)) {\n            searchTerms = [team1, team2];\n            break;\n          }\n        }\n      }\n\n      // Also check for common team names mentioned in the message\n      if (searchTerms.length < 2) {\n        const commonTeams = ['spain', 'france', 'england', 'germany', 'brazil', 'argentina', 'portugal', 'italy', 'netherlands', 'belgium', 'croatia', 'uruguay', 'manchester united', 'manchester city', 'liverpool', 'chelsea', 'arsenal', 'tottenham', 'barcelona', 'real madrid', 'atletico madrid', 'bayern munich', 'borussia dortmund', 'psg', 'juventus', 'ac milan', 'inter milan', 'napoli', 'ajax', 'benfica', 'porto'];\n        const foundTeams = commonTeams.filter(team => messageLower.includes(team.toLowerCase()));\n        if (foundTeams.length >= 2) {\n          searchTerms = foundTeams.slice(0, 2);\n        } else if (foundTeams.length === 1 && searchTerms.length === 1 && searchTerms[0] !== foundTeams[0]) {\n          // If we already found one team through patterns and another through common teams list\n          searchTerms.push(foundTeams[0]);\n        } else if (foundTeams.length === 1 && searchTerms.length === 0) {\n          searchTerms = [foundTeams[0]];\n        }\n      }\n\n      // If we found potential team names, try dynamic match search\n      if (searchTerms.length > 0) {\n        console.log('Searching for match with teams:', searchTerms);\n        const foundMatch = await this.findMatchDynamically(searchTerms);\n        if (foundMatch) {\n          // Get detailed analysis for this specific match\n          const detailedData = foundMatch.id ? await this.getDetailedMatchAnalysis(foundMatch.id) : null;\n          return this.formatComprehensiveMatchAnalysis(foundMatch, detailedData);\n        } else {\n          // No exact match found, but provide helpful alternative\n          return `üîç I couldn't find a specific match with ${searchTerms.join(' and ')} in the current fixtures.\\n\\nüìÖ **Available Matches:**\\n${this.formatUpcomingMatchesResponse(matchData)}\\n\\nüí° Try asking about specific matches from the list above!`;\n        }\n      }\n\n      // Check if API key is available for OpenAI fallback\n      if (!this.apiKey) {\n        return \"I'm currently experiencing technical difficulties connecting to my analysis engine. Please try asking about specific teams, leagues, or matches and I'll do my best to help with the information I have available.\";\n      }\n\n      // Create system prompt with current data for OpenAI\n      const systemPrompt = this.createSystemPrompt(matchData, leagueData);\n\n      // Call OpenAI API for general queries\n      const response = await axios.post(this.baseUrl, {\n        model: 'gpt-3.5-turbo',\n        messages: [{\n          role: 'system',\n          content: systemPrompt\n        }, {\n          role: 'user',\n          content: message\n        }],\n        max_tokens: 500,\n        temperature: 0.7\n      }, {\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        timeout: 10000\n      });\n      if ((_response$data = response.data) !== null && _response$data !== void 0 && (_response$data$choice = _response$data.choices) !== null && _response$data$choice !== void 0 && (_response$data$choice2 = _response$data$choice[0]) !== null && _response$data$choice2 !== void 0 && (_response$data$choice3 = _response$data$choice2.message) !== null && _response$data$choice3 !== void 0 && _response$data$choice3.content) {\n        return response.data.choices[0].message.content.trim();\n      }\n      throw new Error('Invalid response from AI service');\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error('Chat service error:', error);\n\n      // Handle specific error cases\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        return \"I'm having trouble accessing my analysis engine. Please try asking about specific soccer topics like team performance, upcoming matches, or league statistics, and I'll help with the information available.\";\n      }\n      if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) {\n        return \"I'm currently handling a lot of requests. Please wait a moment and try again. In the meantime, feel free to ask about specific teams or matches!\";\n      }\n      if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {\n        return \"My response is taking longer than usual. Could you try rephrasing your question about soccer analytics or asking about a specific team or league?\";\n      }\n\n      // Enhanced fallback responses with real data when OpenAI fails\n      const messageLower = message.toLowerCase();\n\n      // Get fresh match data for fallback responses\n      const [fallbackMatchData] = await Promise.all([this.getRecentMatchData()]);\n\n      // Try dynamic match search for fallback responses\n      const teamNamePatterns = [/(\\w+)\\s+(?:vs?|x|against|\\-)\\s+(\\w+)/g, /(\\w+)\\s+(\\w+)(?:\\s+match|\\s+game|\\s+analysis)/g];\n      let searchTerms = [];\n      for (const pattern of teamNamePatterns) {\n        const matches = [...message.matchAll(pattern)];\n        if (matches.length > 0) {\n          searchTerms = [matches[0][1], matches[0][2]];\n          break;\n        }\n      }\n      if (searchTerms.length > 0) {\n        const foundMatch = await this.findMatchDynamically(searchTerms);\n        if (foundMatch) {\n          const detailedData = foundMatch.id ? await this.getDetailedMatchAnalysis(foundMatch.id) : null;\n          return this.formatComprehensiveMatchAnalysis(foundMatch, detailedData);\n        }\n      }\n\n      // Specific query patterns for fallback\n      if (messageLower.includes('live') || messageLower.includes('going live') || messageLower.includes('now')) {\n        return this.formatLiveMatchesResponse(fallbackMatchData);\n      }\n      if (messageLower.includes('upcoming') || messageLower.includes('today') || messageLower.includes('tomorrow') || messageLower.includes('best matches')) {\n        return this.formatUpcomingMatchesResponse(fallbackMatchData);\n      }\n      if (messageLower.includes('bet') || messageLower.includes('odds') || messageLower.includes('prediction')) {\n        return this.formatBettingInsightsResponse(fallbackMatchData);\n      }\n\n      // Legacy specific match checks (enhanced)\n      if (messageLower.includes('spain') && messageLower.includes('france')) {\n        return this.formatSpecificMatchResponse(fallbackMatchData, 'spain', 'france');\n      }\n      if (messageLower.includes('france') && messageLower.includes('spain')) {\n        return this.formatSpecificMatchResponse(fallbackMatchData, 'france', 'spain');\n      }\n      if (messageLower.includes('hello') || messageLower.includes('hi') || messageLower.includes('hey')) {\n        return `Hello! ‚öΩ Welcome to Odd Genius AI!\\n\\nüî¥ **Currently ${fallbackMatchData.totalLive} live matches** in progress\\nüìÖ **${fallbackMatchData.totalUpcoming} upcoming matches** in the next 7 days\\n\\nI can help you with:\\nüéØ **Live Match Analysis**: Get real-time insights on ongoing games\\nüìä **Upcoming Match Predictions**: Analysis with actual odds and data\\nüí∞ **Betting Insights**: Value bets based on current market data\\nüìà **Specific Team Analysis**: Performance insights\\n\\nTry asking:\\n‚Ä¢ \"Show me live matches\"\\n‚Ä¢ \"What are the best upcoming matches to bet on?\"\\n‚Ä¢ \"Give me betting insights for today\"\\n‚Ä¢ \"France vs Spain analysis\"\\n‚Ä¢ \"When are matches going live?\"\\n\\nWhat would you like to explore? üéØ`;\n      }\n\n      // Enhanced general response with real data context\n      return `I'm here to help with soccer analytics using real-time data! üöÄ\\n\\nüìä **Current Data Available:**\\n‚Ä¢ ${fallbackMatchData.totalLive} live matches in progress\\n‚Ä¢ ${fallbackMatchData.totalUpcoming} upcoming matches (next 7 days)\\n‚Ä¢ Real odds and betting insights\\n‚Ä¢ League analysis from active competitions\\n\\nüéØ **Try These Specific Queries:**\\n‚Ä¢ \"Show me all live matches now\"\\n‚Ä¢ \"What are the best matches to bet on today?\"\\n‚Ä¢ \"Give me odds for upcoming matches\"\\n‚Ä¢ \"France vs Spain analysis\" (or any team combination)\\n‚Ä¢ \"Which live matches have good betting value?\"\\n‚Ä¢ \"When do today's matches start?\"\\n\\nüí° **Tip**: I work best with specific questions about current matches, betting opportunities, or team analysis! I can analyze ANY match from the current fixtures.\\n\\nWhat soccer topic interests you most? ‚öΩ`;\n    }\n  }\n  formatLiveMatchesResponse(matchData) {\n    if (matchData.totalLive === 0) {\n      return \"üî¥ **No Live Matches Currently**\\n\\nThere are no soccer matches being played right now. Check back later for live action!\\n\\nWould you like me to show you upcoming matches instead?\";\n    }\n    const liveMatches = matchData.liveMatches.slice(0, 5);\n    let response = `üî¥ **${matchData.totalLive} LIVE MATCHES NOW**\\n\\n`;\n    liveMatches.forEach((match, index) => {\n      var _match$homeTeam3, _match$score3, _match$score4, _match$awayTeam3, _match$league3;\n      response += `**${index + 1}. ${(_match$homeTeam3 = match.homeTeam) === null || _match$homeTeam3 === void 0 ? void 0 : _match$homeTeam3.name} ${(_match$score3 = match.score) === null || _match$score3 === void 0 ? void 0 : _match$score3.home} - ${(_match$score4 = match.score) === null || _match$score4 === void 0 ? void 0 : _match$score4.away} ${(_match$awayTeam3 = match.awayTeam) === null || _match$awayTeam3 === void 0 ? void 0 : _match$awayTeam3.name}**\\n`;\n      response += `   ‚è±Ô∏è ${match.elapsed}' | üèÜ ${(_match$league3 = match.league) === null || _match$league3 === void 0 ? void 0 : _match$league3.name}\\n`;\n      response += `   üèüÔ∏è ${match.venue || 'Stadium TBA'}\\n`;\n      if (match.odds) {\n        response += `   üí∞ Odds: ${match.odds.home} / ${match.odds.draw} / ${match.odds.away}\\n`;\n      }\n      response += `\\n`;\n    });\n    if (matchData.totalLive > 5) {\n      response += `*...and ${matchData.totalLive - 5} more live matches*\\n\\n`;\n    }\n    response += \"‚ö° **Live Betting Tips:**\\n\";\n    response += \"‚Ä¢ Watch for momentum shifts in close games\\n\";\n    response += \"‚Ä¢ Consider in-play Over/Under based on current pace\\n\";\n    response += \"‚Ä¢ Look for red card opportunities in heated matches\\n\";\n    return response;\n  }\n  formatUpcomingMatchesResponse(matchData) {\n    if (matchData.totalUpcoming === 0) {\n      return \"üìÖ **No Upcoming Matches in Next 7 Days**\\n\\nThere are no soccer matches scheduled for the next week in our database.\\n\\nWould you like me to analyze current league standings or recent form instead?\";\n    }\n    const upcomingMatches = matchData.upcomingMatches.slice(0, 8);\n    let response = `üìÖ **UPCOMING MATCHES (Next 7 Days) - ${matchData.totalUpcoming} Total**\\n\\n`;\n    upcomingMatches.forEach((match, index) => {\n      var _match$homeTeam4, _match$awayTeam4, _match$league4;\n      response += `**${index + 1}. ${(_match$homeTeam4 = match.homeTeam) === null || _match$homeTeam4 === void 0 ? void 0 : _match$homeTeam4.name} vs ${(_match$awayTeam4 = match.awayTeam) === null || _match$awayTeam4 === void 0 ? void 0 : _match$awayTeam4.name}**\\n`;\n      response += `   üìÖ ${match.date} at ${match.time}\\n`;\n      response += `   üèÜ ${(_match$league4 = match.league) === null || _match$league4 === void 0 ? void 0 : _match$league4.name}\\n`;\n      response += `   üèüÔ∏è ${match.venue || 'Venue TBA'}\\n`;\n      if (match.odds) {\n        var _match$probability, _match$probability2, _match$probability3;\n        response += `   üí∞ Odds: Home ${match.odds.home} | Draw ${match.odds.draw} | Away ${match.odds.away}\\n`;\n        response += `   üìä Probability: ${(_match$probability = match.probability) === null || _match$probability === void 0 ? void 0 : _match$probability.home} / ${(_match$probability2 = match.probability) === null || _match$probability2 === void 0 ? void 0 : _match$probability2.draw} / ${(_match$probability3 = match.probability) === null || _match$probability3 === void 0 ? void 0 : _match$probability3.away}\\n`;\n      }\n      if (match.recommended) {\n        response += `   ‚≠ê Recommended: ${match.recommended.toUpperCase()}\\n`;\n      }\n      response += `\\n`;\n    });\n    if (matchData.totalUpcoming > 8) {\n      response += `*...and ${matchData.totalUpcoming - 8} more upcoming matches*\\n\\n`;\n    }\n    response += \"üéØ **Best Betting Opportunities:**\\n\";\n    const goodOddsMatches = upcomingMatches.filter(m => m.odds && (m.odds.home > 1.8 || m.odds.away > 1.8));\n    if (goodOddsMatches.length > 0) {\n      goodOddsMatches.slice(0, 3).forEach(match => {\n        var _match$homeTeam5, _match$awayTeam5;\n        response += `‚Ä¢ **${(_match$homeTeam5 = match.homeTeam) === null || _match$homeTeam5 === void 0 ? void 0 : _match$homeTeam5.name} vs ${(_match$awayTeam5 = match.awayTeam) === null || _match$awayTeam5 === void 0 ? void 0 : _match$awayTeam5.name}** - Good value odds available\\n`;\n      });\n    }\n    return response;\n  }\n  formatBettingInsightsResponse(matchData) {\n    let response = \"üí∞ **SMART BETTING ANALYSIS (Based on Current Data)**\\n\\n\";\n\n    // Analyze live matches for in-play opportunities\n    if (matchData.totalLive > 0) {\n      response += \"üî¥ **Live Betting Opportunities:**\\n\";\n      const liveMatches = matchData.liveMatches.slice(0, 3);\n      liveMatches.forEach(match => {\n        var _match$homeTeam6, _match$awayTeam6, _match$score5, _match$score6, _match$odds4, _match$odds5, _match$odds6;\n        response += `‚Ä¢ **${(_match$homeTeam6 = match.homeTeam) === null || _match$homeTeam6 === void 0 ? void 0 : _match$homeTeam6.name} vs ${(_match$awayTeam6 = match.awayTeam) === null || _match$awayTeam6 === void 0 ? void 0 : _match$awayTeam6.name}** (${(_match$score5 = match.score) === null || _match$score5 === void 0 ? void 0 : _match$score5.home}-${(_match$score6 = match.score) === null || _match$score6 === void 0 ? void 0 : _match$score6.away}, ${match.elapsed}')\\n`;\n        response += `  Current odds: ${(_match$odds4 = match.odds) === null || _match$odds4 === void 0 ? void 0 : _match$odds4.home}/${(_match$odds5 = match.odds) === null || _match$odds5 === void 0 ? void 0 : _match$odds5.draw}/${(_match$odds6 = match.odds) === null || _match$odds6 === void 0 ? void 0 : _match$odds6.away}\\n`;\n      });\n      response += \"\\n\";\n    }\n\n    // Analyze upcoming matches for pre-match value\n    if (matchData.totalUpcoming > 0) {\n      response += \"üìÖ **Pre-Match Value Bets:**\\n\";\n      const valueMatches = matchData.upcomingMatches.filter(m => m.odds && m.recommended).slice(0, 5);\n      valueMatches.forEach(match => {\n        var _match$homeTeam7, _match$awayTeam7, _match$algorithm;\n        response += `‚Ä¢ **${(_match$homeTeam7 = match.homeTeam) === null || _match$homeTeam7 === void 0 ? void 0 : _match$homeTeam7.name} vs ${(_match$awayTeam7 = match.awayTeam) === null || _match$awayTeam7 === void 0 ? void 0 : _match$awayTeam7.name}**\\n`;\n        response += `  üìä Recommended: ${match.recommended.toUpperCase()}\\n`;\n        response += `  üí∞ ${match.recommended} odds: ${match.odds[match.recommended]}\\n`;\n        response += `  üìà Algorithm confidence: ${(_match$algorithm = match.algorithm) === null || _match$algorithm === void 0 ? void 0 : _match$algorithm.confidence}%\\n\\n`;\n      });\n    }\n    response += \"‚ö†Ô∏è **Risk Management Reminders:**\\n\";\n    response += \"‚Ä¢ Never bet more than 2-3% of your bankroll per match\\n\";\n    response += \"‚Ä¢ Track your predictions vs actual outcomes\\n\";\n    response += \"‚Ä¢ Consider team news and injuries before betting\\n\";\n    response += \"‚Ä¢ Use the odds and probabilities shown as guidance\\n\";\n    return response;\n  }\n  formatSpecificMatchResponse(matchData, team1, team2) {\n    // Look for specific match in upcoming data with flexible matching\n    const specificMatch = matchData.upcomingMatches.find(match => {\n      var _match$homeTeam8, _match$awayTeam8;\n      const homeTeam = (((_match$homeTeam8 = match.homeTeam) === null || _match$homeTeam8 === void 0 ? void 0 : _match$homeTeam8.name) || '').toLowerCase();\n      const awayTeam = (((_match$awayTeam8 = match.awayTeam) === null || _match$awayTeam8 === void 0 ? void 0 : _match$awayTeam8.name) || '').toLowerCase();\n      const t1 = team1.toLowerCase();\n      const t2 = team2.toLowerCase();\n      return homeTeam.includes(t1) && awayTeam.includes(t2) || homeTeam.includes(t2) && awayTeam.includes(t1) || homeTeam === t1 && awayTeam === t2 || homeTeam === t2 && awayTeam === t1;\n    });\n    if (specificMatch) {\n      var _specificMatch$homeTe, _specificMatch$awayTe, _specificMatch$league, _specificMatch$league2;\n      let response = `üîç **MATCH ANALYSIS: ${(_specificMatch$homeTe = specificMatch.homeTeam) === null || _specificMatch$homeTe === void 0 ? void 0 : _specificMatch$homeTe.name} vs ${(_specificMatch$awayTe = specificMatch.awayTeam) === null || _specificMatch$awayTe === void 0 ? void 0 : _specificMatch$awayTe.name}**\\n\\n`;\n      response += `üìÖ **Match Details:**\\n`;\n      response += `‚Ä¢ Date: ${specificMatch.date}\\n`;\n      response += `‚Ä¢ Time: ${specificMatch.time}\\n`;\n      response += `‚Ä¢ League: ${(_specificMatch$league = specificMatch.league) === null || _specificMatch$league === void 0 ? void 0 : _specificMatch$league.name}\\n`;\n      response += `‚Ä¢ Venue: ${specificMatch.venue || 'TBA'}\\n\\n`;\n      if (specificMatch.odds) {\n        var _specificMatch$homeTe2, _specificMatch$awayTe2, _specificMatch$probab, _specificMatch$probab2, _specificMatch$probab3;\n        response += `üí∞ **Betting Odds:**\\n`;\n        response += `‚Ä¢ Home Win (${(_specificMatch$homeTe2 = specificMatch.homeTeam) === null || _specificMatch$homeTe2 === void 0 ? void 0 : _specificMatch$homeTe2.name}): ${specificMatch.odds.home}\\n`;\n        response += `‚Ä¢ Draw: ${specificMatch.odds.draw}\\n`;\n        response += `‚Ä¢ Away Win (${(_specificMatch$awayTe2 = specificMatch.awayTeam) === null || _specificMatch$awayTe2 === void 0 ? void 0 : _specificMatch$awayTe2.name}): ${specificMatch.odds.away}\\n\\n`;\n        response += `üìä **Probabilities:**\\n`;\n        response += `‚Ä¢ Home: ${(_specificMatch$probab = specificMatch.probability) === null || _specificMatch$probab === void 0 ? void 0 : _specificMatch$probab.home}\\n`;\n        response += `‚Ä¢ Draw: ${(_specificMatch$probab2 = specificMatch.probability) === null || _specificMatch$probab2 === void 0 ? void 0 : _specificMatch$probab2.draw}\\n`;\n        response += `‚Ä¢ Away: ${(_specificMatch$probab3 = specificMatch.probability) === null || _specificMatch$probab3 === void 0 ? void 0 : _specificMatch$probab3.away}\\n\\n`;\n      }\n      if (specificMatch.recommended) {\n        var _specificMatch$algori;\n        response += `‚≠ê **Our Algorithm Recommends:** ${specificMatch.recommended.toUpperCase()}\\n`;\n        response += `üéØ **Confidence Level:** ${(_specificMatch$algori = specificMatch.algorithm) === null || _specificMatch$algori === void 0 ? void 0 : _specificMatch$algori.confidence}%\\n\\n`;\n      }\n      response += `üé≤ **Betting Markets Analysis:**\\n`;\n      response += `‚Ä¢ **1X2 Market**: ${specificMatch.recommended ? `Consider ${specificMatch.recommended.toUpperCase()} (${specificMatch.odds[specificMatch.recommended]} odds)` : 'Analyze team form'}\\n`;\n      response += `‚Ä¢ **Over/Under Goals**: With teams like these, consider Over 2.5 goals\\n`;\n      response += `‚Ä¢ **Both Teams to Score**: High-quality attacking teams suggest BTTS Yes\\n`;\n      response += `‚Ä¢ **Corners**: Possession-based teams typically generate more corner opportunities\\n\\n`;\n      response += `üìà **Recent Form Context:**\\n`;\n      response += `‚Ä¢ Both teams are top-tier international sides\\n`;\n      response += `‚Ä¢ ${(_specificMatch$league2 = specificMatch.league) === null || _specificMatch$league2 === void 0 ? void 0 : _specificMatch$league2.name} - high-stakes competition\\n`;\n      response += `‚Ä¢ Historical matchups between these teams are often tight\\n`;\n      response += `‚Ä¢ Consider current squad form and injuries before betting\\n`;\n      return response;\n    }\n    return `üîç I couldn't find a specific match between ${team1} and ${team2} in the upcoming fixtures (next 7 days).\\n\\nüìÖ **Current Upcoming Matches:**\\n${this.formatUpcomingMatchesResponse(matchData)}`;\n  }\n  async findMatchDynamically(searchTerms) {\n    try {\n      const [matchData] = await Promise.all([this.getRecentMatchData()]);\n\n      // Search in both live and upcoming matches\n      const allMatches = [...(Array.isArray(matchData.liveMatches) ? matchData.liveMatches : []), ...(Array.isArray(matchData.upcomingMatches) ? matchData.upcomingMatches : [])];\n      if (allMatches.length === 0) {\n        console.log('No matches available for dynamic search');\n        return null;\n      }\n\n      // Normalize search terms - lowercase and trim\n      const normalizedTerms = searchTerms.map(term => term.toLowerCase().trim());\n\n      // First try exact team name matches (more precise)\n      const exactMatch = allMatches.find(match => {\n        var _match$homeTeam9, _match$awayTeam9;\n        const homeTeam = (((_match$homeTeam9 = match.homeTeam) === null || _match$homeTeam9 === void 0 ? void 0 : _match$homeTeam9.name) || '').toLowerCase();\n        const awayTeam = (((_match$awayTeam9 = match.awayTeam) === null || _match$awayTeam9 === void 0 ? void 0 : _match$awayTeam9.name) || '').toLowerCase();\n\n        // Check if search terms exactly match both team names (in any order)\n        return normalizedTerms.includes(homeTeam) && normalizedTerms.includes(awayTeam) || normalizedTerms.length >= 2 && homeTeam === normalizedTerms[0] && awayTeam === normalizedTerms[1] || normalizedTerms.length >= 2 && homeTeam === normalizedTerms[1] && awayTeam === normalizedTerms[0];\n      });\n      if (exactMatch) {\n        console.log('Found exact match for search terms:', normalizedTerms);\n        return exactMatch;\n      }\n\n      // Then try partial team name matches (more flexible)\n      const partialMatch = allMatches.find(match => {\n        var _match$homeTeam0, _match$awayTeam0, _match$league5;\n        const homeTeam = (((_match$homeTeam0 = match.homeTeam) === null || _match$homeTeam0 === void 0 ? void 0 : _match$homeTeam0.name) || '').toLowerCase();\n        const awayTeam = (((_match$awayTeam0 = match.awayTeam) === null || _match$awayTeam0 === void 0 ? void 0 : _match$awayTeam0.name) || '').toLowerCase();\n        const league = (((_match$league5 = match.league) === null || _match$league5 === void 0 ? void 0 : _match$league5.name) || '').toLowerCase();\n\n        // Check if search terms are contained within team names\n        const termMatches = normalizedTerms.map(term => {\n          return homeTeam.includes(term) || awayTeam.includes(term) || league.includes(term);\n        });\n\n        // For a match to be valid, at least 2 terms must match different aspects of the match\n        const matchCount = termMatches.filter(Boolean).length;\n        return matchCount >= Math.min(2, normalizedTerms.length);\n      });\n      if (partialMatch) {\n        console.log('Found partial match for search terms:', normalizedTerms);\n        return partialMatch;\n      }\n\n      // If no match found yet, try with team name similarity\n      const bestMatch = this.findBestMatchingTeams(allMatches, normalizedTerms);\n      if (bestMatch) {\n        console.log('Found best match using similarity for search terms:', normalizedTerms);\n        return bestMatch;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error finding match:', error);\n      return null;\n    }\n  }\n  findBestMatchingTeams(matches, searchTerms) {\n    if (!matches.length || !searchTerms.length) return null;\n    let bestMatch = null;\n    let highestScore = 0;\n    for (const match of matches) {\n      var _match$homeTeam1, _match$awayTeam1;\n      const homeTeam = (((_match$homeTeam1 = match.homeTeam) === null || _match$homeTeam1 === void 0 ? void 0 : _match$homeTeam1.name) || '').toLowerCase();\n      const awayTeam = (((_match$awayTeam1 = match.awayTeam) === null || _match$awayTeam1 === void 0 ? void 0 : _match$awayTeam1.name) || '').toLowerCase();\n\n      // Calculate similarity score for each search term against each team name\n      let matchScore = 0;\n      for (const term of searchTerms) {\n        // Simple similarity check - what percentage of the term is contained in the team name\n        const homeScore = this.calculateSimilarity(term, homeTeam);\n        const awayScore = this.calculateSimilarity(term, awayTeam);\n\n        // Use the better match between home and away for this term\n        matchScore += Math.max(homeScore, awayScore);\n      }\n\n      // Normalize the score\n      matchScore = matchScore / searchTerms.length;\n      if (matchScore > highestScore) {\n        highestScore = matchScore;\n        bestMatch = match;\n      }\n    }\n\n    // Only return a match if the similarity score is high enough\n    return highestScore > 0.5 ? bestMatch : null;\n  }\n  calculateSimilarity(term, teamName) {\n    if (!term || !teamName) return 0;\n\n    // Direct inclusion check\n    if (teamName.includes(term)) return 1.0;\n    if (term.includes(teamName)) return 0.9;\n\n    // Check for abbreviations (e.g., \"man u\" for \"manchester united\")\n    const teamWords = teamName.split(/\\s+/);\n    const termWords = term.split(/\\s+/);\n\n    // If the first letters of each word in the team name match the term\n    if (termWords.length === 1 && teamWords.length > 1) {\n      const abbr = teamWords.map(word => word[0]).join('').toLowerCase();\n      if (term === abbr) return 0.8;\n    }\n\n    // Word-by-word similarity\n    let matchedWords = 0;\n    for (const termWord of termWords) {\n      if (teamWords.some(teamWord => teamWord.includes(termWord) || termWord.includes(teamWord))) {\n        matchedWords++;\n      }\n    }\n    return matchedWords / Math.max(termWords.length, 1);\n  }\n  async getDetailedMatchAnalysis(matchId) {\n    try {\n      var _matchDetails$data, _h2h$data, _corners$data, _btts$data, _cards$data, _analysis$data, _matchData$homeTeam, _matchData$awayTeam;\n      const baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\n\n      // Get comprehensive match data\n      const [matchDetails, h2h, corners, btts, cards, analysis] = await Promise.all([axios.get(`${baseUrl}/matches/${matchId}`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/h2h`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/corners`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/btts`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/cards`).catch(() => ({\n        data: null\n      })), axios.get(`${baseUrl}/matches/${matchId}/analysis`).catch(() => ({\n        data: null\n      }))]);\n\n      // Extract data, handling the possible nested 'result' structure\n      const matchData = ((_matchDetails$data = matchDetails.data) === null || _matchDetails$data === void 0 ? void 0 : _matchDetails$data.result) || matchDetails.data;\n      const h2hData = ((_h2h$data = h2h.data) === null || _h2h$data === void 0 ? void 0 : _h2h$data.result) || h2h.data;\n      const cornersData = ((_corners$data = corners.data) === null || _corners$data === void 0 ? void 0 : _corners$data.result) || corners.data;\n      const bttsData = ((_btts$data = btts.data) === null || _btts$data === void 0 ? void 0 : _btts$data.result) || btts.data;\n      const cardsData = ((_cards$data = cards.data) === null || _cards$data === void 0 ? void 0 : _cards$data.result) || cards.data;\n      const analysisData = ((_analysis$data = analysis.data) === null || _analysis$data === void 0 ? void 0 : _analysis$data.result) || analysis.data;\n\n      // Get team form if we have team IDs\n      let teamForm = {\n        home: null,\n        away: null\n      };\n      if (matchData !== null && matchData !== void 0 && (_matchData$homeTeam = matchData.homeTeam) !== null && _matchData$homeTeam !== void 0 && _matchData$homeTeam.id && matchData !== null && matchData !== void 0 && (_matchData$awayTeam = matchData.awayTeam) !== null && _matchData$awayTeam !== void 0 && _matchData$awayTeam.id) {\n        var _homeForm$data, _awayForm$data;\n        const [homeForm, awayForm] = await Promise.all([axios.get(`${baseUrl}/teams/${matchData.homeTeam.id}/form`).catch(() => ({\n          data: null\n        })), axios.get(`${baseUrl}/teams/${matchData.awayTeam.id}/form`).catch(() => ({\n          data: null\n        }))]);\n        teamForm = {\n          home: ((_homeForm$data = homeForm.data) === null || _homeForm$data === void 0 ? void 0 : _homeForm$data.result) || homeForm.data,\n          away: ((_awayForm$data = awayForm.data) === null || _awayForm$data === void 0 ? void 0 : _awayForm$data.result) || awayForm.data\n        };\n      }\n      return {\n        matchDetails: matchData,\n        h2h: h2hData,\n        corners: cornersData,\n        btts: bttsData,\n        cards: cardsData,\n        analysis: analysisData,\n        teamForm\n      };\n    } catch (error) {\n      console.error('Error getting detailed match analysis:', error);\n      return null;\n    }\n  }\n  formatComprehensiveMatchAnalysis(match, detailedData) {\n    var _match$homeTeam10, _match$awayTeam10, _match$league6;\n    let response = `üîç **COMPREHENSIVE MATCH ANALYSIS**\\n`;\n    response += `**${(_match$homeTeam10 = match.homeTeam) === null || _match$homeTeam10 === void 0 ? void 0 : _match$homeTeam10.name} vs ${(_match$awayTeam10 = match.awayTeam) === null || _match$awayTeam10 === void 0 ? void 0 : _match$awayTeam10.name}**\\n\\n`;\n\n    // Basic match info\n    response += `üìÖ **Match Details:**\\n`;\n    response += `‚Ä¢ Date: ${match.date} at ${match.time}\\n`;\n    response += `‚Ä¢ League: ${(_match$league6 = match.league) === null || _match$league6 === void 0 ? void 0 : _match$league6.name}\\n`;\n    response += `‚Ä¢ Venue: ${match.venue || 'TBA'}\\n`;\n    if (match.status === 'LIVE') {\n      var _match$score7, _match$score8;\n      response += `‚Ä¢ Status: üî¥ LIVE (${match.elapsed}')\\n`;\n      response += `‚Ä¢ Current Score: ${(_match$score7 = match.score) === null || _match$score7 === void 0 ? void 0 : _match$score7.home} - ${(_match$score8 = match.score) === null || _match$score8 === void 0 ? void 0 : _match$score8.away}\\n`;\n    }\n    response += `\\n`;\n\n    // Betting odds and recommendations\n    if (match.odds) {\n      var _match$homeTeam11, _match$awayTeam11;\n      response += `üí∞ **Betting Analysis:**\\n`;\n      response += `‚Ä¢ Home Win (${(_match$homeTeam11 = match.homeTeam) === null || _match$homeTeam11 === void 0 ? void 0 : _match$homeTeam11.name}): ${match.odds.home}\\n`;\n      response += `‚Ä¢ Draw: ${match.odds.draw}\\n`;\n      response += `‚Ä¢ Away Win (${(_match$awayTeam11 = match.awayTeam) === null || _match$awayTeam11 === void 0 ? void 0 : _match$awayTeam11.name}): ${match.odds.away}\\n`;\n      if (match.probability) {\n        response += `‚Ä¢ Probabilities: ${match.probability.home} / ${match.probability.draw} / ${match.probability.away}\\n`;\n      }\n      if (match.recommended) {\n        var _match$algorithm2;\n        response += `‚Ä¢ ‚≠ê **Recommended Bet**: ${match.recommended.toUpperCase()}\\n`;\n        response += `‚Ä¢ üéØ **Confidence**: ${(_match$algorithm2 = match.algorithm) === null || _match$algorithm2 === void 0 ? void 0 : _match$algorithm2.confidence}%\\n`;\n      }\n      response += `\\n`;\n    }\n\n    // Detailed analysis from backend\n    if (detailedData) {\n      // Team Form\n      if (detailedData.teamForm.home || detailedData.teamForm.away) {\n        response += `üìà **Recent Team Form:**\\n`;\n        if (detailedData.teamForm.home) {\n          var _match$homeTeam12;\n          response += `‚Ä¢ **${(_match$homeTeam12 = match.homeTeam) === null || _match$homeTeam12 === void 0 ? void 0 : _match$homeTeam12.name}**: ${detailedData.teamForm.home.recentForm || 'Form data available'}\\n`;\n        }\n        if (detailedData.teamForm.away) {\n          var _match$awayTeam12;\n          response += `‚Ä¢ **${(_match$awayTeam12 = match.awayTeam) === null || _match$awayTeam12 === void 0 ? void 0 : _match$awayTeam12.name}**: ${detailedData.teamForm.away.recentForm || 'Form data available'}\\n`;\n        }\n        response += `\\n`;\n      }\n\n      // Head-to-Head\n      if (detailedData.h2h) {\n        response += `üèÜ **Head-to-Head Record:**\\n`;\n        response += `‚Ä¢ Recent meetings and historical performance data available\\n`;\n        response += `‚Ä¢ Statistical trends and patterns analyzed\\n\\n`;\n      }\n\n      // Corners Analysis\n      if (detailedData.corners) {\n        response += `‚öΩ **Corners Analysis:**\\n`;\n        response += `‚Ä¢ **Over/Under Corners**: Based on team averages and playing styles\\n`;\n        response += `‚Ä¢ **Corner Patterns**: Historical corner data analyzed\\n`;\n        response += `‚Ä¢ **Recommendation**: Check team attacking patterns and defensive setups\\n\\n`;\n      }\n\n      // Goals Analysis (BTTS)\n      if (detailedData.btts) {\n        response += `ü•Ö **Goals Analysis:**\\n`;\n        response += `‚Ä¢ **Both Teams to Score**: Probability based on attacking/defensive records\\n`;\n        response += `‚Ä¢ **Over/Under 2.5 Goals**: Statistical likelihood analysis\\n`;\n        response += `‚Ä¢ **Goal Timing**: Patterns of when teams typically score\\n\\n`;\n      }\n\n      // Cards Analysis\n      if (detailedData.cards) {\n        response += `üü® **Cards Analysis:**\\n`;\n        response += `‚Ä¢ **Yellow Cards**: Expected booking patterns\\n`;\n        response += `‚Ä¢ **Red Cards**: Risk assessment based on team discipline\\n`;\n        response += `‚Ä¢ **Referee Impact**: Historical booking tendencies\\n\\n`;\n      }\n    }\n\n    // Strategic insights\n    response += `üéØ **Key Betting Markets:**\\n`;\n    response += `‚Ä¢ **1X2 Market**: ${match.recommended ? `Consider ${match.recommended.toUpperCase()}` : 'Analyze odds value'}\\n`;\n    response += `‚Ä¢ **Over/Under Goals**: Check team scoring averages and defensive records\\n`;\n    response += `‚Ä¢ **Both Teams to Score**: Evaluate attacking strength vs defensive weaknesses\\n`;\n    response += `‚Ä¢ **Corners**: Consider playing styles (possession vs counter-attack)\\n`;\n    response += `‚Ä¢ **Cards**: Factor in referee strictness and team discipline records\\n\\n`;\n    response += `‚ö†Ô∏è **Risk Considerations:**\\n`;\n    response += `‚Ä¢ Team news and injuries (check latest updates)\\n`;\n    response += `‚Ä¢ Weather conditions and pitch quality\\n`;\n    response += `‚Ä¢ Motivation levels (tournament importance, league position)\\n`;\n    response += `‚Ä¢ Recent form momentum and confidence\\n`;\n    return response;\n  }\n  isValidTeamName(name) {\n    if (!name || name.length < 3) return false;\n\n    // Filter out common words that might be mistaken for team names\n    const commonWords = ['match', 'game', 'team', 'versus', 'against', 'between', 'analysis', 'statistics', 'odds', 'betting', 'prediction', 'today', 'tomorrow', 'yesterday', 'please', 'thanks', 'give', 'show', 'tell', 'about', 'what', 'when', 'where', 'who', 'why', 'how', 'the', 'and', 'for'];\n    if (commonWords.includes(name.toLowerCase())) {\n      return false;\n    }\n\n    // Check that the name doesn't contain common question words or phrases\n    const questionPhrases = ['what is', 'how to', 'can you', 'will you', 'should i', 'do you'];\n    for (const phrase of questionPhrases) {\n      if (name.toLowerCase().includes(phrase)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nexport const chatService = new ChatService();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}