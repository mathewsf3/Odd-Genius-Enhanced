{"ast":null,"code":"import axios from 'axios';\nimport { API_KEY } from '../config/api-config';\n\n// Base URL for the API\nconst BASE_URL = 'https://apiv2.allsportsapi.com/football';\n\n// Helper functions for date formatting\nconst getCurrentDate = () => {\n  const date = new Date();\n  return date.toISOString().split('T')[0];\n};\nconst getDateRange = daysToLookBack => {\n  const date = new Date();\n  date.setDate(date.getDate() - daysToLookBack);\n  return date.toISOString().split('T')[0];\n};\n\n// Cache for BTTS stats data to reduce API calls\nconst bttsStatsCache = {};\n\n// Clear cache function\nconst clearBTTSStatsCache = () => {\n  Object.keys(bttsStatsCache).forEach(key => {\n    delete bttsStatsCache[key];\n  });\n  console.log('[BTTSStatsService] Cache cleared');\n};\n\n// Main function to fetch BTTS statistics\nconst fetchBTTSStats = async (homeTeamId, awayTeamId, gameCount = 10) => {\n  try {\n    // Clean team IDs (remove \"team-\" prefix if present)\n    const cleanHomeTeamId = homeTeamId.toString().replace('team-', '');\n    const cleanAwayTeamId = awayTeamId.toString().replace('team-', '');\n\n    // Create a cache key based on team IDs and game count\n    const cacheKey = `${cleanHomeTeamId}-${cleanAwayTeamId}-${gameCount}`;\n\n    // Check if we have cached data that's less than 1 hour old\n    const cachedData = bttsStatsCache[cacheKey];\n    if (cachedData && Date.now() - cachedData.timestamp < 3600000) {\n      console.log(`[BTTSStatsService] Using cached BTTS stats data for ${cacheKey}`);\n      return cachedData.data;\n    }\n\n    // Clear any existing cache for different game counts to prevent conflicts\n    Object.keys(bttsStatsCache).forEach(key => {\n      if (key.startsWith(`${cleanHomeTeamId}-${cleanAwayTeamId}-`) && key !== cacheKey) {\n        console.log(`[BTTSStatsService] Clearing conflicting cache entry: ${key}`);\n        delete bttsStatsCache[key];\n      }\n    });\n    console.log(`[BTTSStatsService] Fetching BTTS stats for ${cleanHomeTeamId} vs ${cleanAwayTeamId} with ${gameCount} games`);\n\n    // Create an abort controller for timeout handling - FIXED: Much longer timeout for 5-game requests\n    const abortController = new AbortController();\n    const timeoutDuration = gameCount === 5 ? 45000 : 20000; // 45s for 5 games, 20s for 10 games\n    console.log(`[BTTSStatsService] Setting timeout to ${timeoutDuration / 1000} seconds for ${gameCount} games`);\n    const timeoutId = setTimeout(() => {\n      console.error(`[BTTSStatsService] â° REQUEST TIMEOUT after ${timeoutDuration / 1000} seconds for ${gameCount} games`);\n      console.error(`[BTTSStatsService] This is likely causing the infinite loading issue`);\n      abortController.abort();\n    }, timeoutDuration);\n    try {\n      // Fetch team matches for both teams\n      console.log(`[BTTSStatsService] Starting parallel fetch for ${gameCount} games...`);\n      const [homeTeamMatches, awayTeamMatches, h2hMatches] = await Promise.all([fetchTeamMatches(cleanHomeTeamId, gameCount, abortController.signal), fetchTeamMatches(cleanAwayTeamId, gameCount, abortController.signal), fetchH2HMatches(cleanHomeTeamId, cleanAwayTeamId, gameCount, abortController.signal)]);\n      clearTimeout(timeoutId);\n      console.log(`[BTTSStatsService] Parallel fetch completed successfully for ${gameCount} games`);\n      console.log(`[BTTSStatsService] Retrieved ${homeTeamMatches.length} home team matches, ${awayTeamMatches.length} away team matches, and ${h2hMatches.length} H2H matches`);\n\n      // Process matches to extract BTTS statistics\n      const homeTeamStats = await processTeamBTTSStats(cleanHomeTeamId, homeTeamMatches);\n      const awayTeamStats = await processTeamBTTSStats(cleanAwayTeamId, awayTeamMatches);\n      const h2hStats = processH2HBTTSStats(cleanHomeTeamId, cleanAwayTeamId, h2hMatches);\n\n      // Calculate combined statistics - FIXED: Pass gameCount parameter\n      const combinedStats = calculateCombinedBTTSStats(homeTeamStats, awayTeamStats, h2hStats, gameCount);\n\n      // Create the result object\n      const result = {\n        homeStats: homeTeamStats,\n        awayStats: awayTeamStats,\n        h2hStats,\n        combinedStats,\n        isFallbackData: false\n      };\n\n      // Cache the result\n      bttsStatsCache[cacheKey] = {\n        data: result,\n        timestamp: Date.now()\n      };\n      console.log(`[BTTSStatsService] Successfully processed BTTS stats for ${gameCount} games`);\n      return result;\n    } catch (fetchError) {\n      clearTimeout(timeoutId);\n      console.error(`[BTTSStatsService] Error during parallel fetch for ${gameCount} games:`, fetchError);\n\n      // If it's an abort error, provide specific message\n      if (fetchError instanceof Error && fetchError.name === 'AbortError') {\n        throw new Error(`Request timeout: BTTS statistics took too long to load for ${gameCount} games`);\n      }\n      throw new Error(`Failed to fetch BTTS statistics for ${gameCount} games: ${fetchError instanceof Error ? fetchError.message : 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('[BTTSStatsService] Error fetching BTTS statistics:', error);\n    throw new Error(`Failed to fetch BTTS statistics: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n};\n\n// Fetch team matches from the API\nconst fetchTeamMatches = async (teamId, count, signal) => {\n  try {\n    console.log(`[BTTSStatsService] Fetching matches for team ${teamId}`);\n\n    // Get a slightly wider date range to ensure we get enough matches\n    const daysToLookBack = count <= 5 ? 90 : count <= 10 ? 180 : 365;\n\n    // Use direct URL construction to avoid any potential issues with axios params\n    const url = `${BASE_URL}/?met=Fixtures&teamId=${teamId}&from=${getDateRange(daysToLookBack)}&to=${getCurrentDate()}&APIkey=${API_KEY}`;\n    console.log(`[BTTSStatsService] Making API request to: ${url.replace(API_KEY, 'API_KEY_HIDDEN')}`);\n    const response = await axios.get(url, {\n      signal,\n      timeout: count === 5 ? 20000 : 10000,\n      // Much longer timeout for 5-game requests\n      decompress: true\n    });\n\n    // Extract match data and return most recent 'count' matches\n    const matches = response.data.result || [];\n    console.log(`[BTTSStatsService] API response for team ${teamId}: Found ${matches.length} matches`);\n    if (matches.length === 0) {\n      console.warn(`[BTTSStatsService] No matches found for team ID ${teamId}`);\n      throw new Error(`No matches found for team ID ${teamId}`);\n    }\n    return matches.sort((a, b) => new Date(b.event_date).getTime() - new Date(a.event_date).getTime()).slice(0, count).map(match => {\n      var _match$home_team, _match$away_team, _match$home_team2;\n      return {\n        id: match.event_key,\n        date: match.event_date,\n        homeTeamId: match.home_team_key || ((_match$home_team = match.home_team) === null || _match$home_team === void 0 ? void 0 : _match$home_team.team_key),\n        homeTeamName: match.event_home_team,\n        awayTeamId: match.away_team_key || ((_match$away_team = match.away_team) === null || _match$away_team === void 0 ? void 0 : _match$away_team.team_key),\n        awayTeamName: match.event_away_team,\n        homeScore: parseInt(match.event_final_result.split(' - ')[0]),\n        awayScore: parseInt(match.event_final_result.split(' - ')[1]),\n        isHome: (match.home_team_key || ((_match$home_team2 = match.home_team) === null || _match$home_team2 === void 0 ? void 0 : _match$home_team2.team_key)) === teamId,\n        league: match.league_name,\n        country: match.country_name\n      };\n    });\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log(`[BTTSStatsService] Request aborted for team ${teamId}`);\n      throw new Error(`Request timeout for team ${teamId} matches`);\n    }\n    if (error instanceof Error && error.code === 'ECONNABORTED') {\n      console.log(`[BTTSStatsService] Request timeout for team ${teamId}`);\n      throw new Error(`Request timeout for team ${teamId} matches`);\n    }\n    console.error(`[BTTSStatsService] Error fetching team matches for team ${teamId}:`, error);\n    throw new Error(`Failed to fetch matches for team ${teamId}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n};\n\n// Fetch head-to-head matches from the API\nconst fetchH2HMatches = async (homeTeamId, awayTeamId, count, signal) => {\n  try {\n    var _response$data$result;\n    console.log(`[BTTSStatsService] Fetching H2H matches for teams ${homeTeamId} vs ${awayTeamId}`);\n\n    // Use direct URL construction\n    const url = `${BASE_URL}/?met=H2H&firstTeamId=${homeTeamId}&secondTeamId=${awayTeamId}&APIkey=${API_KEY}`;\n    console.log(`[BTTSStatsService] Making API request to: ${url.replace(API_KEY, 'API_KEY_HIDDEN')}`);\n    const response = await axios.get(url, {\n      signal,\n      timeout: count === 5 ? 20000 : 10000,\n      // Much longer timeout for 5-game requests\n      decompress: true\n    });\n\n    // Extract H2H matches\n    const h2hData = ((_response$data$result = response.data.result) === null || _response$data$result === void 0 ? void 0 : _response$data$result.H2H) || [];\n    console.log(`[BTTSStatsService] API response: Found ${h2hData.length} H2H matches`);\n    if (h2hData.length === 0) {\n      console.warn(`[BTTSStatsService] No H2H matches found for teams ${homeTeamId} vs ${awayTeamId}`);\n      return [];\n    }\n    return h2hData.sort((a, b) => new Date(b.event_date).getTime() - new Date(a.event_date).getTime()).slice(0, count).map(match => ({\n      id: match.event_key,\n      date: match.event_date,\n      homeTeamId: match.home_team_key,\n      homeTeamName: match.event_home_team,\n      awayTeamId: match.away_team_key,\n      awayTeamName: match.event_away_team,\n      homeScore: parseInt(match.event_final_result.split(' - ')[0]),\n      awayScore: parseInt(match.event_final_result.split(' - ')[1]),\n      league: match.league_name,\n      country: match.country_name\n    }));\n  } catch (error) {\n    console.error(`[BTTSStatsService] Error fetching H2H matches:`, error);\n    return []; // Return empty array instead of throwing to allow the rest of the data to be processed\n  }\n};\n\n// Process team matches to extract BTTS statistics\nconst processTeamBTTSStats = async (teamId, matches) => {\n  console.log(`[BTTSStatsService] Processing ${matches.length} matches for team ${teamId}`);\n\n  // Enhanced debugging for BTTS calculation\n  console.log(`[BTTSStatsService] Team ${teamId} matches:`, matches.map(m => ({\n    id: m.id,\n    date: m.date,\n    opponent: m.isHome ? m.awayTeamName : m.homeTeamName,\n    venue: m.isHome ? 'Home' : 'Away',\n    score: `${m.homeScore}-${m.awayScore}`,\n    goalsScored: m.isHome ? m.homeScore : m.awayScore,\n    goalsConceded: m.isHome ? m.awayScore : m.homeScore\n  })));\n\n  // Initialize counters\n  let totalMatches = matches.length;\n  let bttsYesCount = 0;\n  let cleanSheetCount = 0;\n  let failedToScoreCount = 0;\n\n  // Home/Away specific counters\n  let homeMatches = 0;\n  let homeBttsYesCount = 0;\n  let homeCleanSheetCount = 0;\n  let homeFailedToScoreCount = 0;\n  let awayMatches = 0;\n  let awayBttsYesCount = 0;\n  let awayCleanSheetCount = 0;\n  let awayFailedToScoreCount = 0;\n\n  // Recent form tracking\n  const recentForm = [];\n\n  // Process each match\n  for (const match of matches) {\n    // Determine if this is a home or away match for the team we're analyzing\n    const isHome = match.homeTeamId === teamId;\n\n    // Calculate goals scored and conceded based on whether this is a home or away match\n    const goalsScored = isHome ? match.homeScore : match.awayScore;\n    const goalsConceded = isHome ? match.awayScore : match.homeScore;\n\n    // Get the opponent name, making sure it's not the same as the team we're analyzing\n    const opponent = isHome ? match.awayTeamName : match.homeTeamName;\n\n    // Debug log to verify correct data\n    console.log(`[BTTSStatsService] Processing match for team ${teamId}: ${isHome ? 'Home' : 'Away'} vs ${opponent}, Score: ${goalsScored}-${goalsConceded}`);\n\n    // Check BTTS - FIXED: Both teams must score for BTTS = Yes\n    const bttsResult = goalsScored > 0 && goalsConceded > 0 ? 'Yes' : 'No';\n    if (bttsResult === 'Yes') bttsYesCount++;\n\n    // Check clean sheet - FIXED: Clean sheet = team conceded 0 goals\n    const cleanSheet = goalsConceded === 0;\n    if (cleanSheet) cleanSheetCount++;\n\n    // Check failed to score - FIXED: Failed to score = team scored 0 goals\n    const failedToScore = goalsScored === 0;\n    if (failedToScore) failedToScoreCount++;\n\n    // Enhanced logging for each match\n    console.log(`[BTTSStatsService] Match ${match.id}: ${match.isHome ? match.homeTeamName : match.awayTeamName} vs ${match.isHome ? match.awayTeamName : match.homeTeamName}`);\n    console.log(`  Score: ${match.homeScore}-${match.awayScore} | Goals For: ${goalsScored} | Goals Against: ${goalsConceded}`);\n    console.log(`  BTTS: ${bttsResult} | Clean Sheet: ${cleanSheet} | Failed to Score: ${failedToScore}`);\n\n    // Track home/away stats\n    if (isHome) {\n      homeMatches++;\n      if (bttsResult === 'Yes') homeBttsYesCount++;\n      if (cleanSheet) homeCleanSheetCount++;\n      if (failedToScore) homeFailedToScoreCount++;\n    } else {\n      awayMatches++;\n      if (bttsResult === 'Yes') awayBttsYesCount++;\n      if (cleanSheet) awayCleanSheetCount++;\n      if (failedToScore) awayFailedToScoreCount++;\n    }\n\n    // Add to recent form\n    recentForm.push({\n      matchId: match.id,\n      date: match.date,\n      opponent,\n      isHome,\n      goalsScored,\n      goalsConceded,\n      bttsResult,\n      cleanSheet,\n      failedToScore\n    });\n  }\n\n  // Calculate percentages - FIXED: Use precise calculation, round only for display\n  const bttsYesPercentage = totalMatches > 0 ? Math.round(bttsYesCount / totalMatches * 100) : 0;\n  const cleanSheetPercentage = totalMatches > 0 ? Math.round(cleanSheetCount / totalMatches * 100) : 0;\n  const failedToScorePercentage = totalMatches > 0 ? Math.round(failedToScoreCount / totalMatches * 100) : 0;\n\n  // Enhanced summary logging\n  console.log(`[BTTSStatsService] SUMMARY for team ${teamId}:`);\n  console.log(`  Total matches: ${totalMatches}`);\n  console.log(`  BTTS Yes: ${bttsYesCount}/${totalMatches} = ${bttsYesPercentage}%`);\n  console.log(`  Clean Sheets: ${cleanSheetCount}/${totalMatches} = ${cleanSheetPercentage}%`);\n  console.log(`  Failed to Score: ${failedToScoreCount}/${totalMatches} = ${failedToScorePercentage}%`);\n  const homeBttsYesPercentage = homeMatches > 0 ? Math.round(homeBttsYesCount / homeMatches * 100) : 0;\n  const homeCleanSheetPercentage = homeMatches > 0 ? Math.round(homeCleanSheetCount / homeMatches * 100) : 0;\n  const homeFailedToScorePercentage = homeMatches > 0 ? Math.round(homeFailedToScoreCount / homeMatches * 100) : 0;\n  const awayBttsYesPercentage = awayMatches > 0 ? Math.round(awayBttsYesCount / awayMatches * 100) : 0;\n  const awayCleanSheetPercentage = awayMatches > 0 ? Math.round(awayCleanSheetCount / awayMatches * 100) : 0;\n  const awayFailedToScorePercentage = awayMatches > 0 ? Math.round(awayFailedToScoreCount / awayMatches * 100) : 0;\n\n  // Log detailed statistics for verification\n  console.log(`[BTTSStatsService] Team ${teamId} BTTS statistics summary:`);\n  console.log(`[BTTSStatsService] - Total matches: ${totalMatches}`);\n  console.log(`[BTTSStatsService] - BTTS Yes: ${bttsYesCount} (${bttsYesPercentage}%)`);\n  console.log(`[BTTSStatsService] - Clean sheets: ${cleanSheetCount} (${cleanSheetPercentage}%)`);\n  console.log(`[BTTSStatsService] - Failed to score: ${failedToScoreCount} (${failedToScorePercentage}%)`);\n  return {\n    teamId,\n    totalMatches,\n    bttsYesCount,\n    bttsYesPercentage,\n    cleanSheetCount,\n    cleanSheetPercentage,\n    failedToScoreCount,\n    failedToScorePercentage,\n    homeMatches,\n    homeBttsYesCount,\n    homeBttsYesPercentage,\n    homeCleanSheetCount,\n    homeCleanSheetPercentage,\n    homeFailedToScoreCount,\n    homeFailedToScorePercentage,\n    awayMatches,\n    awayBttsYesCount,\n    awayBttsYesPercentage,\n    awayCleanSheetCount,\n    awayCleanSheetPercentage,\n    awayFailedToScoreCount,\n    awayFailedToScorePercentage,\n    recentForm\n  };\n};\n\n// Process H2H matches to extract BTTS statistics\nconst processH2HBTTSStats = (homeTeamId, _awayTeamId, matches) => {\n  // Note: awayTeamId is prefixed with underscore to indicate it's not used directly\n  console.log(`[BTTSStatsService] Processing ${matches.length} H2H matches`);\n\n  // Initialize counters\n  const totalMatches = matches.length;\n  let bttsYesCount = 0;\n  let homeTeamWins = 0;\n  let awayTeamWins = 0;\n  let draws = 0;\n  let homeTeamGoals = 0;\n  let awayTeamGoals = 0;\n\n  // Recent form tracking\n  const recentH2HForm = [];\n\n  // Process each match\n  for (const match of matches) {\n    const homeScore = match.homeScore;\n    const awayScore = match.awayScore;\n\n    // Check BTTS\n    const bttsResult = homeScore > 0 && awayScore > 0 ? 'Yes' : 'No';\n    if (bttsResult === 'Yes') bttsYesCount++;\n\n    // Track match result\n    if (homeScore > awayScore) {\n      if (match.homeTeamId === homeTeamId) {\n        homeTeamWins++;\n      } else {\n        awayTeamWins++;\n      }\n    } else if (homeScore < awayScore) {\n      if (match.homeTeamId === homeTeamId) {\n        awayTeamWins++;\n      } else {\n        homeTeamWins++;\n      }\n    } else {\n      draws++;\n    }\n\n    // Track goals\n    if (match.homeTeamId === homeTeamId) {\n      homeTeamGoals += homeScore;\n      awayTeamGoals += awayScore;\n    } else {\n      homeTeamGoals += awayScore;\n      awayTeamGoals += homeScore;\n    }\n\n    // Add to recent form\n    const isHomeTeamHome = match.homeTeamId === homeTeamId;\n    const homeTeamName = match.homeTeamName || \"Home Team\";\n    const awayTeamName = match.awayTeamName || \"Away Team\";\n\n    // Create a descriptive match string that clearly shows home vs away\n    const matchDescription = `${homeTeamName} ${homeScore}-${awayScore} ${awayTeamName}`;\n    recentH2HForm.push({\n      matchId: match.id,\n      date: match.date,\n      opponent: matchDescription,\n      isHome: isHomeTeamHome,\n      goalsScored: isHomeTeamHome ? homeScore : awayScore,\n      goalsConceded: isHomeTeamHome ? awayScore : homeScore,\n      bttsResult,\n      cleanSheet: isHomeTeamHome ? awayScore === 0 : homeScore === 0,\n      failedToScore: isHomeTeamHome ? homeScore === 0 : awayScore === 0\n    });\n  }\n\n  // Calculate percentages and averages - FIXED: Use same precision as H2H History section\n  const bttsYesPercentage = totalMatches > 0 ? Math.round(bttsYesCount / totalMatches * 100) : 0;\n  const averageTotalGoals = totalMatches > 0 ? Math.round((homeTeamGoals + awayTeamGoals) / totalMatches * 100) / 100 : 0;\n\n  // Log detailed statistics for verification\n  console.log(`[BTTSStatsService] H2H BTTS statistics summary:`);\n  console.log(`[BTTSStatsService] - Total matches: ${totalMatches}`);\n  console.log(`[BTTSStatsService] - BTTS Yes: ${bttsYesCount} (${bttsYesPercentage}%)`);\n  console.log(`[BTTSStatsService] - Home team wins: ${homeTeamWins}, Away team wins: ${awayTeamWins}, Draws: ${draws}`);\n  console.log(`[BTTSStatsService] - Average total goals: ${averageTotalGoals}`);\n  return {\n    totalMatches,\n    bttsYesCount,\n    bttsYesPercentage,\n    homeTeamWins,\n    awayTeamWins,\n    draws,\n    homeTeamGoals,\n    awayTeamGoals,\n    averageTotalGoals,\n    recentH2HForm\n  };\n};\n\n// Calculate combined BTTS statistics\nconst calculateCombinedBTTSStats = (homeTeamStats, awayTeamStats, h2hStats, gameCount = 10 // FIXED: Accept gameCount parameter instead of hardcoding 5\n) => {\n  // Calculate BTTS probability based on actual selected game count\n  const visibleMatches = Math.min(homeTeamStats.recentForm.length, awayTeamStats.recentForm.length, gameCount);\n\n  // Recalculate BTTS percentages based on visible matches\n  const homeVisibleBTTS = homeTeamStats.recentForm.slice(0, visibleMatches).filter(match => match.bttsResult === 'Yes').length;\n  const awayVisibleBTTS = awayTeamStats.recentForm.slice(0, visibleMatches).filter(match => match.bttsResult === 'Yes').length;\n\n  // Calculate percentages based on visible matches - FIXED: Don't mutate original stats\n  const homeVisibleBTTSPercentage = visibleMatches > 0 ? Math.round(homeVisibleBTTS / visibleMatches * 100) : 0;\n  const awayVisibleBTTSPercentage = visibleMatches > 0 ? Math.round(awayVisibleBTTS / visibleMatches * 100) : 0;\n\n  // FIXED: Don't overwrite original stats - keep them separate for display\n  // Original stats remain intact for \"Team BTTS Rates\" cards\n  // Visible stats are used only for probability calculation\n\n  // Recalculate H2H BTTS if available - FIXED: Use correct game count\n  let h2hVisibleBTTSPercentage = 0;\n  if (h2hStats.totalMatches > 0) {\n    const h2hVisibleMatches = Math.min(h2hStats.recentH2HForm.length, gameCount);\n    const h2hVisibleBTTS = h2hStats.recentH2HForm.slice(0, h2hVisibleMatches).filter(match => match.bttsResult === 'Yes').length;\n    h2hVisibleBTTSPercentage = h2hVisibleMatches > 0 ? Math.round(h2hVisibleBTTS / h2hVisibleMatches * 100) : 0;\n\n    // FIXED: Don't overwrite original H2H stats - they should remain as calculated from all matches\n    // h2hStats.bttsYesPercentage = h2hVisibleBTTSPercentage; // Removed\n    // h2hStats.bttsYesCount = h2hVisibleBTTS; // Removed\n  }\n  console.log(`[BTTSStatsService] Recalculated BTTS stats based on ${visibleMatches} visible matches:`);\n  console.log(`Home team BTTS: ${homeVisibleBTTS}/${visibleMatches} (${homeVisibleBTTSPercentage}%)`);\n  console.log(`Away team BTTS: ${awayVisibleBTTS}/${visibleMatches} (${awayVisibleBTTSPercentage}%)`);\n  if (h2hStats.totalMatches > 0) {\n    const h2hVisibleMatches = Math.min(h2hStats.recentH2HForm.length, gameCount);\n    const h2hVisibleBTTS = h2hStats.recentH2HForm.slice(0, h2hVisibleMatches).filter(match => match.bttsResult === 'Yes').length;\n    console.log(`H2H BTTS: ${h2hVisibleBTTS}/${h2hVisibleMatches} (${h2hVisibleBTTSPercentage}%)`);\n  }\n\n  // Calculate BTTS probability based on weighted average\n  // 40% weight to home team's BTTS rate\n  // 40% weight to away team's BTTS rate\n  // 20% weight to H2H BTTS rate (if available)\n  let bttsYesProbability = 0;\n  if (h2hStats.totalMatches > 0) {\n    bttsYesProbability = Math.round(homeVisibleBTTSPercentage * 0.4 + awayVisibleBTTSPercentage * 0.4 + h2hVisibleBTTSPercentage * 0.2);\n  } else {\n    bttsYesProbability = Math.round(homeVisibleBTTSPercentage * 0.5 + awayVisibleBTTSPercentage * 0.5);\n  }\n\n  // Determine confidence level based on probability ranges\n  // Low: 40-60%, Medium: 30-40%/60-70%, High: <30%/>70%\n  let confidenceLevel;\n  if (bttsYesProbability >= 40 && bttsYesProbability <= 60) {\n    confidenceLevel = 'Low';\n  } else if (bttsYesProbability >= 30 && bttsYesProbability < 40 || bttsYesProbability > 60 && bttsYesProbability <= 70) {\n    confidenceLevel = 'Medium';\n  } else if (bttsYesProbability >= 20 && bttsYesProbability < 30 || bttsYesProbability > 70 && bttsYesProbability <= 80) {\n    confidenceLevel = 'High';\n  } else {\n    confidenceLevel = 'Very High';\n  }\n  console.log(`[BTTSStatsService] BTTS Probability: ${bttsYesProbability}%, Confidence Level: ${confidenceLevel}`);\n\n  // Determine prediction based on probability thresholds\n  // OVER for >55%, UNDER for <45%, and PUSH for 45-55%\n  let prediction;\n\n  // Round to nearest whole number to avoid floating point issues\n  const roundedProbability = Math.round(bttsYesProbability);\n  if (roundedProbability > 55) {\n    prediction = 'Yes';\n  } else if (roundedProbability < 45) {\n    prediction = 'No';\n  } else {\n    prediction = 'Uncertain';\n  }\n  console.log(`[BTTSStatsService] BTTS Prediction: ${prediction} (${bttsYesProbability}%)`);\n\n  // For 50% probability, always use 'Uncertain' prediction\n  if (roundedProbability === 50) {\n    prediction = 'Uncertain';\n    console.log(`[BTTSStatsService] Corrected to PUSH for 50% probability`);\n  }\n\n  // Make historical percentages 4-5% higher than prediction percentages\n  // This is just for display purposes to match the user's requirements\n  if (prediction === 'Yes' && bttsYesProbability < 65) {\n    bttsYesProbability = Math.min(bttsYesProbability + 4, 100);\n  } else if (prediction === 'No' && 100 - bttsYesProbability < 65) {\n    bttsYesProbability = Math.max(bttsYesProbability - 4, 0);\n  }\n\n  // Calculate average goals based on selected game count - FIXED: Use gameCount not hardcoded 5\n  let averageHomeTeamGoals = 0;\n  let averageAwayTeamGoals = 0;\n  let averageTotalGoals = 0;\n\n  // Use the actual game count selected by user\n  const goalCalculationMatches = Math.min(homeTeamStats.recentForm.length, awayTeamStats.recentForm.length, gameCount);\n  const visibleHomeGoals = homeTeamStats.recentForm.slice(0, goalCalculationMatches).reduce((sum, match) => sum + match.goalsScored, 0);\n  const visibleAwayGoals = awayTeamStats.recentForm.slice(0, goalCalculationMatches).reduce((sum, match) => sum + match.goalsScored, 0);\n  if (h2hStats.totalMatches > 0) {\n    // Use H2H data for more accurate predictions - FIXED: Use correct game count\n    const h2hGoalMatches = Math.min(h2hStats.recentH2HForm.length, gameCount);\n    const visibleH2HMatches = h2hStats.recentH2HForm.slice(0, h2hGoalMatches);\n    const h2hHomeGoals = visibleH2HMatches.reduce((sum, match) => sum + (match.isHome ? match.goalsScored : match.goalsConceded), 0);\n    const h2hAwayGoals = visibleH2HMatches.reduce((sum, match) => sum + (match.isHome ? match.goalsConceded : match.goalsScored), 0);\n    const h2hTotalGoals = visibleH2HMatches.reduce((sum, match) => sum + match.goalsScored + match.goalsConceded, 0);\n    averageHomeTeamGoals = visibleH2HMatches.length > 0 ? Math.round(h2hHomeGoals / visibleH2HMatches.length * 100) / 100 : 0;\n    averageAwayTeamGoals = visibleH2HMatches.length > 0 ? Math.round(h2hAwayGoals / visibleH2HMatches.length * 100) / 100 : 0;\n    averageTotalGoals = visibleH2HMatches.length > 0 ? Math.round(h2hTotalGoals / visibleH2HMatches.length * 100) / 100 : 0;\n\n    // Update the H2H stats object\n    h2hStats.homeTeamGoals = h2hHomeGoals;\n    h2hStats.awayTeamGoals = h2hAwayGoals;\n    h2hStats.averageTotalGoals = averageTotalGoals;\n    console.log(`[BTTSStatsService] Using visible H2H data for goal averages: Home=${averageHomeTeamGoals.toFixed(1)}, Away=${averageAwayTeamGoals.toFixed(1)}, Total=${averageTotalGoals.toFixed(1)}`);\n  } else {\n    // Fall back to individual team stats if no H2H data - FIXED: Use correct match count\n    averageHomeTeamGoals = goalCalculationMatches > 0 ? Math.round(visibleHomeGoals / goalCalculationMatches * 100) / 100 : 0;\n    averageAwayTeamGoals = goalCalculationMatches > 0 ? Math.round(visibleAwayGoals / goalCalculationMatches * 100) / 100 : 0;\n    averageTotalGoals = Math.round((averageHomeTeamGoals + averageAwayTeamGoals) * 100) / 100;\n    console.log(`[BTTSStatsService] Using visible team stats for goal averages (${goalCalculationMatches} matches): Home=${averageHomeTeamGoals.toFixed(2)}, Away=${averageAwayTeamGoals.toFixed(2)}, Total=${averageTotalGoals.toFixed(2)}`);\n  }\n\n  // Round to 2 decimal places for consistency with H2H History section\n  averageHomeTeamGoals = Math.round(averageHomeTeamGoals * 100) / 100;\n  averageAwayTeamGoals = Math.round(averageAwayTeamGoals * 100) / 100;\n  averageTotalGoals = Math.round(averageTotalGoals * 100) / 100;\n\n  // Calculate clean sheet probabilities - FIXED: Use correct game count for consistency\n  // Use the same game count as selected by user\n\n  // Recalculate clean sheet percentages based on selected game count\n  const cleanSheetMatches = Math.min(homeTeamStats.recentForm.length, awayTeamStats.recentForm.length, gameCount);\n  const homeVisibleCleanSheets = homeTeamStats.recentForm.slice(0, cleanSheetMatches).filter(match => match.goalsConceded === 0).length;\n  const awayVisibleCleanSheets = awayTeamStats.recentForm.slice(0, cleanSheetMatches).filter(match => match.goalsConceded === 0).length;\n\n  // Recalculate failed to score percentages based on selected game count - FIXED\n  const homeVisibleFailedToScore = homeTeamStats.recentForm.slice(0, cleanSheetMatches).filter(match => match.goalsScored === 0).length;\n  const awayVisibleFailedToScore = awayTeamStats.recentForm.slice(0, cleanSheetMatches).filter(match => match.goalsScored === 0).length;\n\n  // Calculate percentages based on selected game count - FIXED\n  const homeTeamCleanSheetProbability = cleanSheetMatches > 0 ? Math.round(homeVisibleCleanSheets / cleanSheetMatches * 100) : 0;\n  const awayTeamCleanSheetProbability = cleanSheetMatches > 0 ? Math.round(awayVisibleCleanSheets / cleanSheetMatches * 100) : 0;\n  const homeTeamFailToScoreProbability = cleanSheetMatches > 0 ? Math.round(homeVisibleFailedToScore / cleanSheetMatches * 100) : 0;\n  const awayTeamFailToScoreProbability = cleanSheetMatches > 0 ? Math.round(awayVisibleFailedToScore / cleanSheetMatches * 100) : 0;\n  console.log(`[BTTSStatsService] Recalculated stats based on ${cleanSheetMatches} selected matches (gameCount=${gameCount}):`);\n  console.log(`Home team clean sheets: ${homeVisibleCleanSheets}/${cleanSheetMatches} (${homeTeamCleanSheetProbability}%)`);\n  console.log(`Away team clean sheets: ${awayVisibleCleanSheets}/${cleanSheetMatches} (${awayTeamCleanSheetProbability}%)`);\n  console.log(`Home team failed to score: ${homeVisibleFailedToScore}/${cleanSheetMatches} (${homeTeamFailToScoreProbability}%)`);\n  console.log(`Away team failed to score: ${awayVisibleFailedToScore}/${cleanSheetMatches} (${awayTeamFailToScoreProbability}%)`);\n\n  // FIXED: Don't overwrite original stats - keep them for display consistency\n  // Original stats should remain as calculated from the full dataset\n  // These recalculated values are used only for probability calculations\n  // homeTeamStats.cleanSheetPercentage = homeTeamCleanSheetProbability; // Removed\n  // homeTeamStats.cleanSheetCount = homeVisibleCleanSheets; // Removed\n  // homeTeamStats.failedToScorePercentage = homeTeamFailToScoreProbability; // Removed\n  // homeTeamStats.failedToScoreCount = homeVisibleFailedToScore; // Removed\n\n  // awayTeamStats.cleanSheetPercentage = awayTeamCleanSheetProbability; // Removed\n  // awayTeamStats.cleanSheetCount = awayVisibleCleanSheets; // Removed\n  // awayTeamStats.failedToScorePercentage = awayTeamFailToScoreProbability; // Removed\n  // awayTeamStats.failedToScoreCount = awayVisibleFailedToScore; // Removed\n\n  return {\n    bttsYesProbability,\n    confidenceLevel,\n    prediction,\n    averageHomeTeamGoals,\n    averageAwayTeamGoals,\n    averageTotalGoals,\n    homeTeamCleanSheetProbability,\n    awayTeamCleanSheetProbability,\n    homeTeamFailToScoreProbability,\n    awayTeamFailToScoreProbability\n  };\n};\nexport default {\n  fetchBTTSStats,\n  clearBTTSStatsCache\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}